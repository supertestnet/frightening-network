<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, user-scalable=no">
        <script src="https://unpkg.com/@cmdcode/tapscript@1.4.3"></script>
        <script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
        <script src="https://unpkg.com/@dashincubator/ripemd160/ripemd160.js"></script>
        <script>
            function hexToBytes( hex ) {
                return Uint8Array.from( hex.match( /.{1,2}/g ).map( ( byte ) => parseInt( byte, 16 ) ) );
            }

            function bytesToHex( bytes ) {
                return bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, "0" ), "" );
            }
            var rmd160 = s => {
                if ( typeof s == "string" ) s = new TextEncoder().encode( s );
                var hash = RIPEMD160.create();
                hash.update( new Uint8Array( s ) );
                return bytesToHex( hash.digest() );
            }
            var sha256 = s => {
                if ( typeof s == "string" ) s = new TextEncoder().encode( s );
                return crypto.subtle.digest( 'SHA-256', s ).then( hashBuffer => {
                    var hashArray = Array.from( new Uint8Array( hashBuffer ) );
                    var hashHex = hashArray
                        .map( bytes => bytes.toString( 16 ).padStart( 2, '0' ) )
                        .join( '' );
                    return hashHex;
                });
            }
        </script>
        <style>
            * {
                box-sizing: border-box;
                font-size: 1.15rem;
                font-family: Arial, sans-serif;
            }
            html {
                max-width: 70ch;
                padding: 3rem 1rem;
                margin: auto;
                line-height: 1.25;
            }
            h1 {
                font-size: 2rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            input {
                line-height: 1.25;
                width: 100%;
                height: 1.8rem;
                font-size: 1.15rem;
                border: 1px solid grey;
            }
            @media screen and (max-width: 600px) {
            }
        </style>
        <script>
            var $ = document.querySelector.bind( document );
            var $$ = document.querySelectorAll.bind( document );
            var url_params = new URLSearchParams( window.location.search );
            var url_keys = url_params.keys();
            var $_GET = {}
            for ( var key of url_keys ) $_GET[ key ] = url_params.get( key );
        </script>
        <script>
            var getRand = size => bytesToHex(crypto.getRandomValues(new Uint8Array(size)));
            var changeStateWithHtlc = async () => {
                var am_sending = confirm( `Click ok if you are sending or cancel if you are receiving` );
                var channel_identifier = "first_channel";
                var privkey = paul_channels[ channel_identifier ][ "privkey" ];
                if ( am_sending ) {
                    var vickys_data = prompt( `enter the data from Vicky` );
                    vickys_data = JSON.parse( vickys_data );
                    var pmthash = vickys_data[ 3 ];
                    var channel_identifier = vickys_data[ 1 ];
                    var vickys_key = paul_channels[ channel_identifier ][ "vickys_key" ];
                    if ( !( "old_states" in paul_channels[ channel_identifier ] ) ) paul_channels[ channel_identifier ][ "old_states" ] = [];
                    var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length;
                    var msgnum = 6;
                    var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${pmthash}`;
                    console.log( 0, msg_to_sign, pmthash, vickys_data );
                    var msghash = await sha256( msg_to_sign );
                    var sig = vickys_data[ 2 ];
                    var sig_is_valid = await nobleSecp256k1.verify( sig, msghash, vickys_key );
                    if ( !sig_is_valid ) return;
                } else {
                    var amt = prompt( `How many sats do you want Vicky to send you? Must be less than ${paul_channels[ "first_channel" ][ "balance" ][ "remote" ]} sats` );
                    amt = Number( amt );
                    var preimage = getRand( 32 );
                    var pmthash = await sha256( hexToBytes( preimage ) );
                    if ( !( "old_states" in paul_channels[ channel_identifier ] ) ) paul_channels[ channel_identifier ][ "old_states" ] = [];
                    var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length;
                    var msgnum = 5;
                    var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${pmthash}${amt}`;
                    var msghash = await sha256( msg_to_sign );
                    var sig = await nobleSecp256k1.sign( msghash, privkey );
                    console.log( "send this to Vicky:", JSON.stringify( [ msgnum, channel_identifier, sig, pmthash, amt ] ) );
                }
                if ( !am_sending ) {
                    await changeState( pmthash, preimage, 0, amt );
                    var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length;
                    var msgnum = 40;
                    var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${preimage}`;
                    var msghash = await sha256( msg_to_sign );
                    var sig = await nobleSecp256k1.sign( msghash, privkey );
                    console.log( `send this info to Vicky: ${JSON.stringify( [ msgnum, channel_identifier, sig, preimage ] )}` );
                } else {
                    await changeState( pmthash, preimage );
                    var vickys_info = prompt( `enter a preimage from Vicky` );
                    vickys_info = JSON.parse( vickys_info );
                    var preimage = vickys_info[ 3 ];
                    var channel_identifier = vickys_info[ 1 ];
                    var vickys_key = paul_channels[ channel_identifier ][ "vickys_key" ];
                    var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length;
                    var msgnum = 45;
                    var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${preimage}`;
                    console.log( "msg_to_sign:", msg_to_sign, "preimage:", preimage, "vickys_info:", vickys_info );
                    var msghash = await sha256( msg_to_sign );
                    var sig = vickys_info[ 2 ];
                    var sig_is_valid = await nobleSecp256k1.verify( sig, msghash, vickys_key );
                    console.log( msg_to_sign, sig, msghash, vickys_key, sig_is_valid );
                    //todo: automate the force close
                    if ( !sig_is_valid ) return alert( `Something went wrong with the preimage! Time to force close` );
                }
                var resolve_htlc = true;
                var real_pmthash = await sha256( hexToBytes( preimage ) );
                var claimed_pmthash = paul_channels[ "first_channel" ][ "force_close_txs" ][ "pmthash" ];
                //todo: automate the force close
                if ( real_pmthash != claimed_pmthash ) return alert( `Oh no! Your counterparty gave you a bad preimage! Time to force close!` );
                changeState( "", preimage, resolve_htlc );
            }
            function generateHtlcWherePaulReceives(paulPubkey, vickyPubkey, pmthash, timelock) {
                return [
                    'OP_SIZE',
                    32,
                    'OP_EQUALVERIFY',
                    'OP_SHA256',
                    pmthash,
                    'OP_EQUAL',
                    'OP_IF',
                        paulPubkey,
                    'OP_ELSE',
                        timelock,
                        'OP_CHECKSEQUENCEVERIFY',
                        'OP_DROP',
                        vickyPubkey,
                    'OP_ENDIF',
                    'OP_CHECKSIG'
                ];
            }
            function generateHtlcWhereVickyReceives(paulPubkey, vickyPubkey, pmthash, timelock) {
                return [
                    'OP_SIZE',
                    32,
                    'OP_EQUALVERIFY',
                    'OP_SHA256',
                    pmthash,
                    'OP_EQUAL',
                    'OP_IF',
                        vickyPubkey,
                    'OP_ELSE',
                        timelock,
                        'OP_CHECKSEQUENCEVERIFY',
                        'OP_DROP',
                        paulPubkey,
                    'OP_ENDIF',
                    'OP_CHECKSIG'
                ];
            }
            var mempool_checker = txid => {
                var txhex = prompt( `Please enter the txhex of a tx with this txid: ${txid}` );
                var tx = tapscript.Tx.decode( txhex );
                var witness_stack = tx.vin[ 0 ].witness;
                var vickys_publication_preimage = witness_stack[ 3 ];
                var vickys_revocation_preimage = null;
                var pauls_publication_preimage = null;
                var pauls_revocation_preimage = null;
                var vickys_address = paul_channels[ "first_channel" ][ "vickys_address" ];
                var pauls_address = paul_channels[ "first_channel" ][ "pauls_address" ];
                var vickys_key = paul_channels[ "first_channel" ][ "vickys_key" ];
                var pauls_key = paul_channels[ "first_channel" ][ "pauls_key" ];
                var privkey = paul_channels[ "first_channel" ][ "privkey" ];
                //todo: also check if this is the to_reveal tx, in which case
                //you don't need to look for a preimage, just prepare a justice
                //tx and broadcast it after waiting 10 blocks
                paul_channels[ "first_channel" ][ "old_states" ].every( ( item, index ) => {
                    var old_state_txid = item[ "other_partys_to_delay_txid" ];
                    if ( old_state_txid == txid ) {
                        if ( "vickys_revocation_preimage" in item ) vickys_revocation_preimage = item[ "vickys_revocation_preimage" ];
                        pauls_publication_preimage = item[ "pauls_publication_preimage" ];
                        pauls_revocation_preimage = item[ "pauls_revocation_preimage" ];
                        return;
                    }
                    return true;
                });
                if ( !vickys_revocation_preimage ) return;
                var justice_txdata = tapscript.Tx.create({
                  vin  : [{
                    txid: txid,
                    vout: 0,
                    prevout: {
                      value: Number( tx.vout[ 0 ].value ),
                      scriptPubKey: tx.vout[ 0 ].scriptPubKey
                    },
                  }],
                  vout : [{
                    value: Number( tx.vout[ 0 ].value ) - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( pauls_address )
                  }]
                });
                var justice_scripts = [
                    [ 'OP_RIPEMD160', rmd160( hexToBytes( vickys_publication_preimage ) ), 'OP_EQUALVERIFY', 'OP_RIPEMD160', rmd160( hexToBytes( vickys_revocation_preimage ) ), 'OP_EQUALVERIFY', pauls_key.substring( 2 ), 'OP_CHECKSIG' ],
                    [ 0, pauls_key.substring( 2 ), 'OP_CHECKSIGADD', vickys_key.substring( 2 ), 'OP_CHECKSIGADD', 2, 'OP_EQUALVERIFY', 1 * 7, 'OP_CHECKSEQUENCEVERIFY', 'OP_0NOTEQUAL' ],
                    [ 'OP_RIPEMD160', rmd160( hexToBytes( pauls_publication_preimage ) ), 'OP_EQUALVERIFY', 'OP_RIPEMD160', rmd160( hexToBytes( pauls_revocation_preimage ) ), 'OP_EQUALVERIFY', vickys_key.substring( 2 ), 'OP_CHECKSIG' ],
                ];
                var justice_tree = justice_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                var [ justice_tpubkey, justice_cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: justice_tree, target: tapscript.Tap.encodeScript( justice_scripts[ 0 ] ) });
                var sig = tapscript.Signer.taproot.sign( privkey, justice_txdata, 0, { extension: tapscript.Tap.encodeScript( justice_scripts[ 0 ] ) });
                //the order of the witness stack is: publication preimage furthest "forward", revocation preimage next "back", sig furthest back
                justice_txdata.vin[ 0 ].witness = [ sig.hex, vickys_revocation_preimage, vickys_publication_preimage, justice_scripts[ 0 ], justice_cblock ];
                var justice_txhex = tapscript.Tx.encode( justice_txdata ).hex;
            }
            var changeState = async ( pmthash, preimage, resolve_htlc, amount_paul_wants ) => {
                var pauls_key = paul_channels[ "first_channel" ][ "pauls_key" ];
                var privkey = paul_channels[ "first_channel" ][ "privkey" ];
                if ( resolve_htlc ) var expected_amount_for_paul = paul_channels[ "first_channel" ][ "tx_funding_amt" ] + 500 - paul_channels[ "first_channel" ][ "balance" ][ "remote" ];
                var pauls_new_publication_preimage = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                var pauls_new_publication_hash = rmd160( hexToBytes( pauls_new_publication_preimage ) );
                var pauls_new_revocation_preimage = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                var pauls_new_revocation_hash = rmd160( hexToBytes( pauls_new_revocation_preimage ) );
                var vickys_data = prompt( `enter Vicky's new pub & rev hashes & amount` );
                vickys_data = JSON.parse( vickys_data );
                var vickys_new_publication_hash = vickys_data[ 3 ];
                var vickys_new_revocation_hash = vickys_data[ 4 ];
                var amount_for_paul = vickys_data[ 5 ];
                var channel_identifier = vickys_data[ 1 ];
                var vickys_key = paul_channels[ channel_identifier ][ "vickys_key" ];
                var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length + 1;
                var msgnum = 10;
                var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${vickys_new_publication_hash}${vickys_new_revocation_hash}${amount_for_paul}`;
                var msghash = await sha256( msg_to_sign );
                var sig = vickys_data[ 2 ];
                var sig_is_valid = await nobleSecp256k1.verify( sig, msghash, vickys_key );
                //todo: automate the force close
                if ( !sig_is_valid ) return alert( `Something went wrong with message 10! Time to force close!` );
                if ( expected_amount_for_paul && expected_amount_for_paul != expected_amount_for_paul ) return alert( `Oh no, they tried to send you the wrong amount! Time to force close` );
                if ( amount_for_paul > paul_channels[ "first_channel" ][ "tx_funding_amt" ] + 500 ) return;
                //don't send money to Vicky if you don't have a sufficient reserve built up yet
                if ( amount_for_paul <= paul_channels[ "first_channel" ][ "balance" ][ "reserve" ] ) return;
                var amount_paul_currently_has = paul_channels[ "first_channel" ][ "balance" ][ "local" ] + paul_channels[ "first_channel" ][ "balance" ][ "reserve" ];
                var amount_paul_will_get = amount_for_paul - amount_paul_currently_has;
                if ( amount_paul_will_get == 0 && !resolve_htlc ) return;
                if ( amount_paul_will_get > 0 ) var msg = `Do you want Vicky to send you ${amount_paul_will_get} sats?`;
                else var msg = `Do you want to send Vicky ${Math.abs( amount_paul_will_get )} sats?`;
                if ( amount_paul_will_get == 0 && resolve_htlc || amount_paul_wants && amount_paul_will_get == amount_paul_wants ) var conf = true;
                else var conf = confirm( msg );
                if ( amount_paul_wants && amount_paul_will_get != amount_paul_wants ) return;
                if ( !conf ) return;
                var vickys_key = paul_channels[ "first_channel" ][ "vickys_key" ];
                var new_post_funding_script_paul = [
                    'OP_RIPEMD160',
                    pauls_new_publication_hash,
                    'OP_EQUAL',
                    'OP_IF',
                        2,
                        pauls_key,
                        vickys_key,
                        2,
                        'OP_CHECKMULTISIG',
                    'OP_ELSE',
                        'OP_10',
                        'OP_CHECKSEQUENCEVERIFY',
                        'OP_DROP',
                        vickys_key,
                        'OP_CHECKSIG',
                    'OP_ENDIF',
                ];
                // var tx_funding_script = [ 2, pauls_key, vickys_key, 2, 'OP_CHECKMULTISIG' ];
                var new_post_funding_address_paul = tapscript.Address.p2wsh.fromScript( new_post_funding_script_paul, "regtest" );
                var new_post_funding_script_vicky = [
                    'OP_RIPEMD160',
                    vickys_new_publication_hash,
                    'OP_EQUAL',
                    'OP_IF',
                        2,
                        pauls_key,
                        vickys_key,
                        2,
                        'OP_CHECKMULTISIG',
                    'OP_ELSE',
                        'OP_10',
                        'OP_CHECKSEQUENCEVERIFY',
                        'OP_DROP',
                        pauls_key,
                        'OP_CHECKSIG',
                    'OP_ENDIF',
                ];
                // var tx_funding_script = [ 2, pauls_key, vickys_key, 2, 'OP_CHECKMULTISIG' ];
                var new_post_funding_address_vicky = tapscript.Address.p2wsh.fromScript( new_post_funding_script_vicky, "regtest" );
                var new_tx_commit_scripts = [
                    [ 'OP_RIPEMD160', vickys_new_publication_hash, 'OP_EQUALVERIFY', 'OP_RIPEMD160', vickys_new_revocation_hash, 'OP_EQUALVERIFY', pauls_key.substring( 2 ), 'OP_CHECKSIG' ],
                    [ 0, pauls_key.substring( 2 ), 'OP_CHECKSIGADD', vickys_key.substring( 2 ), 'OP_CHECKSIGADD', 2, 'OP_EQUALVERIFY', 1 * 7, 'OP_CHECKSEQUENCEVERIFY', 'OP_0NOTEQUAL' ],
                    [ 'OP_RIPEMD160', pauls_new_publication_hash, 'OP_EQUALVERIFY', 'OP_RIPEMD160', pauls_new_revocation_hash, 'OP_EQUALVERIFY', vickys_key.substring( 2 ), 'OP_CHECKSIG' ],
                ];
                var new_tx_commit_tree = new_tx_commit_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                var [ new_tx_commit_tpubkey, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: new_tx_commit_tree, target: tapscript.Tap.encodeScript( new_tx_commit_scripts[ 1 ] ) });
                var new_tx_commit_cblock = cblock;
                var new_tx_commit_address = tapscript.Address.p2tr.fromPubKey( new_tx_commit_tpubkey, 'regtest' );
                var prev_tx_funding = tapscript.Tx.decode( paul_channels[ "first_channel" ][ "force_close_txs" ][ "to_reveal" ] );
                var tx_funding_txid = prev_tx_funding[ "vin" ][ 0 ][ "txid" ];
                var tx_funding_vout = prev_tx_funding[ "vin" ][ 0 ][ "vout" ];
                var tx_funding_amt = paul_channels[ "first_channel" ][ "tx_funding_amt" ];
                var tx_funding_address = paul_channels[ "first_channel" ][ "tx_funding_address" ];
                var tx_funding_script = paul_channels[ "first_channel" ][ "tx_funding_script" ];
                var new_tx_funding_txdata = tapscript.Tx.create({
                  vin  : [{
                    txid: tx_funding_txid,
                    vout: tx_funding_vout,
                    prevout: {
                      value: tx_funding_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( tx_funding_address )
                    },
                  }],
                  vout : [{
                    value: tx_funding_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( new_post_funding_address_paul )
                  }]
                });
                var new_tx_funding_pauls_sig = tapscript.Signer.segwit.sign( privkey, new_tx_funding_txdata, 0, { script: tx_funding_script });
                var new_tx_funding_txhex = tapscript.Tx.encode( new_tx_funding_txdata ).hex;
                var new_post_funding_txid = tapscript.Tx.util.getTxid( new_tx_funding_txhex );
                var new_post_funding_vout = 0;
                var new_post_funding_amt = tx_funding_amt - 500;
                var new_post_funding_txdata = tapscript.Tx.create({
                  vin  : [{
                    txid: new_post_funding_txid,
                    vout: new_post_funding_vout,
                    prevout: {
                      value: new_post_funding_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( new_post_funding_address_paul )
                    },
                  }],
                  vout : [{
                    value: new_post_funding_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( new_tx_commit_address )
                  }]
                });
                var sighash = tapscript.Signer.segwit.hash( new_post_funding_txdata, 0, { script: new_post_funding_script_paul } );
                var new_post_funding_pauls_sig = tapscript.Signer.segwit.sign( privkey, new_post_funding_txdata, 0, { script: new_post_funding_script_paul });
                var new_post_funding_txhex = tapscript.Tx.encode( new_post_funding_txdata ).hex;
                var new_tx_commit_txid = tapscript.Tx.util.getTxid( new_post_funding_txhex );
                var new_tx_commit_vout = 0;
                var new_tx_commit_amt = new_post_funding_amt - 500;
                //todo: get this address from elsewhere
                var pauls_address = 'bcrt1q738hdjlatdx9xmg3679kwq9cwd7fa2c84my9zk';
                paul_channels[ "first_channel" ][ "pauls_address" ] = pauls_address;
                var vickys_address = paul_channels[ "first_channel" ][ "vickys_address" ];
                var new_tx_commit_txdata = tapscript.Tx.create({
                  vin  : [{
                    txid: new_tx_commit_txid,
                    vout: new_tx_commit_vout,
                    //todo: fix this sequence
                    // sequence: 144 * 7,
                    sequence: 1 * 7,
                    prevout: {
                      value: new_tx_commit_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( new_tx_commit_address )
                    },
                  }],
                  vout : []
                });
                var timelock = 8;
                if ( pmthash && amount_paul_will_get > 0 ) {
                    var htlc_script = generateHtlcWherePaulReceives( pauls_key, vickys_key, pmthash, timelock );
                    var htlc_address = tapscript.Address.p2wsh.fromScript( htlc_script, "regtest" );
                    new_tx_commit_txdata[ "vout" ].push({
                        value: new_tx_commit_amt - amount_for_paul - 500,
                        scriptPubKey: tapscript.Address.toScriptPubKey( vickys_address )
                    },{
                        value: amount_for_paul,
                        scriptPubKey: tapscript.Address.toScriptPubKey( htlc_address )
                    });
                }
                if ( pmthash && amount_paul_will_get < 0 ) {
                    var htlc_script = generateHtlcWhereVickyReceives( pauls_key, vickys_key, pmthash, timelock );
                    var htlc_address = tapscript.Address.p2wsh.fromScript( htlc_script, "regtest" );
                    new_tx_commit_txdata[ "vout" ].push({
                        value: new_tx_commit_amt - amount_for_paul - 500,
                        scriptPubKey: tapscript.Address.toScriptPubKey( htlc_address )
                    },{
                        value: amount_for_paul,
                        scriptPubKey: tapscript.Address.toScriptPubKey( pauls_address )
                    });
                }
                if ( !pmthash ) {
                    new_tx_commit_txdata[ "vout" ].push({
                        value: new_tx_commit_amt - amount_for_paul - 500,
                        scriptPubKey: tapscript.Address.toScriptPubKey( vickys_address )
                    },{
                        value: amount_for_paul,
                        scriptPubKey: tapscript.Address.toScriptPubKey( pauls_address )
                    });
                }
                if ( pmthash ) {
                    var new_tx_commit_txhex = tapscript.Tx.encode( new_tx_commit_txdata ).hex;
                    var new_htlc_txid = tapscript.Tx.util.getTxid( new_tx_commit_txhex );
                    if ( preimage ) {
                        var htlc_script = generateHtlcWherePaulReceives( pauls_key, vickys_key, pmthash, timelock );
                        var htlc_address = tapscript.Address.p2wsh.fromScript( htlc_script, "regtest" );
                        var htlc_txdata = tapscript.Tx.create({
                          vin  : [{
                            txid: new_htlc_txid,
                            vout: 1,
                            prevout: {
                              value: amount_for_paul,
                              scriptPubKey: tapscript.Address.toScriptPubKey( htlc_address )
                            },
                          }],
                          vout : [{
                            value: amount_for_paul - 500,
                            scriptPubKey: tapscript.Address.toScriptPubKey( pauls_address )
                          }]
                        });
                        var htlc_sig = tapscript.Signer.segwit.sign( privkey, htlc_txdata, 0, {script: htlc_script} );
                        var sighash = tapscript.Signer.segwit.hash( htlc_txdata, 0, { script: htlc_script } );
                        var sig_is_good = await nobleSecp256k1.verify( htlc_sig.hex.substring( 0, htlc_sig.hex.length - 2 ), sighash.hex, pauls_key );
                        htlc_txdata.vin[ 0 ].witness = [ htlc_sig, preimage, htlc_script ];
                        var htlc_txhex_if_paul_received_and_paul_broadcasted = tapscript.Tx.encode( htlc_txdata ).hex;
                    } else {
                        var htlc_script = generateHtlcWhereVickyReceives( pauls_key, vickys_key, pmthash, timelock );
                        var htlc_address = tapscript.Address.p2wsh.fromScript( htlc_script, "regtest" );
                        var htlc_txdata = tapscript.Tx.create({
                          vin  : [{
                            txid: new_htlc_txid,
                            vout: 0,
                            seqence: timelock,
                            prevout: {
                              value: new_tx_commit_amt - amount_for_paul - 500,
                              scriptPubKey: tapscript.Address.toScriptPubKey( htlc_address )
                            },
                          }],
                          vout : [{
                            value: new_tx_commit_amt - amount_for_paul - 500 - 500,
                            scriptPubKey: tapscript.Address.toScriptPubKey( pauls_address )
                          }]
                        });
                        var htlc_sig = tapscript.Signer.segwit.sign( privkey, htlc_txdata, 0, {script: htlc_script} );
                        htlc_txdata.vin[ 0 ].witness = [ htlc_sig, "ab".repeat( 32 ), htlc_script ];
                        var htlc_txhex_if_vicky_received_and_paul_broadcasted = tapscript.Tx.encode( htlc_txdata ).hex;
                    }
                }
                var new_tx_commit_pauls_sig_vicky = tapscript.Signer.taproot.sign( privkey, new_tx_commit_txdata, 0, { extension: tapscript.Tap.encodeScript( new_tx_commit_scripts[ 1 ] ) });
                var vickys_amt = new_tx_commit_amt - amount_for_paul - 500;
                var new_tx_commit_pauls_sig = tapscript.Signer.taproot.sign( privkey, new_tx_commit_txdata, 0, { extension: tapscript.Tap.encodeScript( new_tx_commit_scripts[ 1 ] ) });
                var channel_identifier = "first_channel";
                var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length + 1;
                var msgnum = 15;
                var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${pauls_new_publication_hash}${pauls_new_revocation_hash}${pauls_address}`;
                var msghash = await sha256( msg_to_sign );
                var sig = await nobleSecp256k1.sign( msghash, privkey );
                console.log( `new pub & rev hashes & btc address: ${JSON.stringify( [ msgnum, channel_identifier, sig, pauls_new_publication_hash, pauls_new_revocation_hash, pauls_address] )}` );
                alert( `Give Vicky the data in your console` );
                var vickys_data = prompt( `enter Vicky's three new signatures` );
                vickys_data = JSON.parse( vickys_data );
                var channel_identifier = vickys_data[ 1 ];
                var vickys_key = paul_channels[ channel_identifier ][ "vickys_key" ];
                var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length + 1;
                var msgnum = 20;
                var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${vickys_data[ 3 ]}${vickys_data[ 4 ]}${vickys_data[ 5 ]}`;
                var msghash = await sha256( msg_to_sign );
                var sig = vickys_data[ 2 ];
                var sig_is_valid = await nobleSecp256k1.verify( sig, msghash, vickys_key );
                //todo: automate the force close
                if ( !sig_is_valid ) return alert( `Something went wrong with message 20! Time to force close!` );
                //the following sig should move the money from the funding address to the new_post_funding address
                var new_tx_funding_vickys_sig = vickys_data[ 3 ];
                var sighash = tapscript.Signer.segwit.hash( new_tx_funding_txdata, 0, { script: tx_funding_script } );
                var sigflag = new_tx_funding_vickys_sig.substring( new_tx_funding_vickys_sig.length - 2 );
                if ( sigflag != "01" ) return alert( `new_tx_funding sig was not good due to bad sigflag! Aborting, broadcast these transactions:\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "to_reveal" ]}\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "to_delay" ]}\n\nThen wait 1008 blocks, then broadcast this transaction:\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "final_tx" ]}` );
                var sig_is_good = await nobleSecp256k1.verify( new_tx_funding_vickys_sig.substring( 0, new_tx_funding_vickys_sig.length - 2 ), bytesToHex( sighash ), vickys_key );
                if ( !sig_is_good ) return alert( `new_tx_funding sig was not good due to not validating! Aborting, broadcast these transactions:\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "to_reveal" ]}\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "to_delay" ]}\n\nThen wait 1008 blocks, then broadcast this transaction:\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "final_tx" ]}` );
                new_tx_funding_txdata.vin[ 0 ].witness = [ 0, new_tx_funding_pauls_sig, new_tx_funding_vickys_sig, tx_funding_script ];
                var new_tx_funding_txhex = tapscript.Tx.encode( new_tx_funding_txdata ).hex;
                //the following sig should move the money from the new_post_funding address to the new_tx_commit address
                var new_post_funding_vickys_sig = vickys_data[ 4 ];
                var sighash = tapscript.Signer.segwit.hash( new_post_funding_txdata, 0, { script: new_post_funding_script_paul } );
                var sigflag = new_post_funding_vickys_sig.substring( new_post_funding_vickys_sig.length - 2 );
                if ( sigflag != "01" ) return alert( `new_post_funding sig was not good! Aborting, broadcast these transactions:\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "to_reveal" ]}\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "to_delay" ]}\n\nThen wait 1008 blocks, then broadcast this transaction:\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "final_tx" ]}` );
                var sig_is_good = await nobleSecp256k1.verify( new_post_funding_vickys_sig.substring( 0, new_post_funding_vickys_sig.length - 2 ), bytesToHex( sighash ), vickys_key );
                if ( !sig_is_good ) return alert( `new_post_funding sig was not good! Aborting, broadcast these transactions:\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "to_reveal" ]}\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "to_delay" ]}\n\nThen wait 1008 blocks, then broadcast this transaction:\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "final_tx" ]}` );
                new_post_funding_txdata.vin[ 0 ].witness = [ 0, new_post_funding_pauls_sig, new_post_funding_vickys_sig, pauls_new_publication_preimage, new_post_funding_script_paul ];
                var new_post_funding_txhex = tapscript.Tx.encode( new_post_funding_txdata ).hex;
                //the following sig should move the money from the new_tx_commit address to vicky
                var new_tx_commit_vickys_sig = vickys_data[ 5 ];
                var sighash = tapscript.Signer.taproot.hash( new_tx_commit_txdata, 0, { extension: tapscript.Tap.encodeScript( new_tx_commit_scripts[ 1 ] ) } );
                if ( new_tx_commit_vickys_sig.length > 128 ) return alert( `new_tx_commit sig was not good! Aborting, broadcast these transactions:\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "to_reveal" ]}\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "to_delay" ]}\n\nThen wait 1008 blocks, then broadcast this transaction:\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "final_tx" ]}` );
                var sig_is_good = await nobleSecp256k1.schnorr.verify( new_tx_commit_pauls_sig, bytesToHex( sighash ), pauls_key.substring( 2 ) );
                if ( !sig_is_good ) return alert( `new_tx_commit sig was not good! Aborting, broadcast these transactions:\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "to_reveal" ]}\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "to_delay" ]}\n\nThen wait 1008 blocks, then broadcast this transaction:\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "final_tx" ]}` );
                new_tx_commit_txdata.vin[ 0 ].witness = [ new_tx_commit_vickys_sig, new_tx_commit_pauls_sig, new_tx_commit_scripts[ 1 ], new_tx_commit_cblock ];
                var new_tx_commit_txhex = tapscript.Tx.encode( new_tx_commit_txdata ).hex;
                var old_state = paul_channels[ "first_channel" ][ "force_close_txs" ];
                paul_channels[ "first_channel" ][ "old_states" ].push( old_state );
                var new_state = {
                    to_reveal: new_tx_funding_txhex,
                    to_delay: new_post_funding_txhex,
                    final_tx: new_tx_commit_txhex,
                    vickys_publication_hash: vickys_new_publication_hash,
                    vickys_revocation_hash: vickys_new_revocation_hash,
                    pauls_publication_preimage: pauls_new_publication_preimage,
                    pauls_revocation_preimage: pauls_new_revocation_preimage,
                }
                if ( pmthash && htlc_txhex_if_paul_received_and_paul_broadcasted ) new_state[ "htlc_txhex_if_paul_received_and_paul_broadcasted" ] = htlc_txhex_if_paul_received_and_paul_broadcasted;
                if ( pmthash && htlc_txhex_if_vicky_received_and_paul_broadcasted ) paul_channels[ "first_channel" ][ "force_close_txs" ][ "htlc_txhex_if_vicky_received_and_paul_broadcasted" ] = htlc_txhex_if_vicky_received_and_paul_broadcasted;
                if ( pmthash ) new_state[ "pmthash" ] = pmthash;
                if ( preimage ) new_state[ "preimage" ] = preimage;
                paul_channels[ "first_channel" ][ "force_close_txs" ] = new_state;
                if ( !( "balance" in paul_channels[ "first_channel" ] ) ) paul_channels[ "first_channel" ][ "balance" ] = {}
                var reserve_amount_before_update = paul_channels[ "first_channel" ][ "balance" ][ "reserve" ];
                paul_channels[ "first_channel" ][ "balance" ][ "reserve" ] = amount_for_paul > 2000 ? 2000 : amount_for_paul;
                var reserve_amount_after_update = paul_channels[ "first_channel" ][ "balance" ][ "reserve" ];
                var amount_added_to_reserve = reserve_amount_after_update - reserve_amount_before_update;
                paul_channels[ "first_channel" ][ "balance" ][ "local" ] = amount_for_paul > 2000 ? amount_for_paul - 2000 : amount_for_paul;
                paul_channels[ "first_channel" ][ "balance" ][ "remote" ] = paul_channels[ "first_channel" ][ "tx_funding_amt" ] + 500 - ( paul_channels[ "first_channel" ][ "balance" ][ "reserve" ] + paul_channels[ "first_channel" ][ "balance" ][ "local" ] );
                //versions for vicky
                var new_tx_funding_txdata = tapscript.Tx.create({
                  vin  : [{
                    txid: tx_funding_txid,
                    vout: tx_funding_vout,
                    prevout: {
                      value: tx_funding_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( tx_funding_address )
                    },
                  }],
                  vout : [{
                    value: tx_funding_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( new_post_funding_address_vicky )
                  }]
                });
                var new_tx_funding_pauls_sig_vicky = tapscript.Signer.segwit.sign( privkey, new_tx_funding_txdata, 0, { script: tx_funding_script });
                var new_tx_funding_txhex = tapscript.Tx.encode( new_tx_funding_txdata ).hex;
                var new_post_funding_txid = tapscript.Tx.util.getTxid( new_tx_funding_txhex );
                paul_channels[ "first_channel" ][ "force_close_txs" ][ "other_partys_to_reveal_txid" ] = new_post_funding_txid;
                var new_post_funding_vout = 0;
                var new_post_funding_amt = tx_funding_amt - 500;
                var new_post_funding_txdata = tapscript.Tx.create({
                  vin  : [{
                    txid: new_post_funding_txid,
                    vout: new_post_funding_vout,
                    prevout: {
                      value: new_post_funding_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( new_post_funding_address_vicky )
                    },
                  }],
                  vout : [{
                    value: new_post_funding_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( new_tx_commit_address )
                  }]
                });
                var sighash = tapscript.Signer.segwit.hash( new_post_funding_txdata, 0, { script: new_post_funding_script_vicky } );
                var new_post_funding_pauls_sig_vicky = tapscript.Signer.segwit.sign( privkey, new_post_funding_txdata, 0, { script: new_post_funding_script_vicky });
                var new_post_funding_txhex = tapscript.Tx.encode( new_post_funding_txdata ).hex;
                var new_tx_commit_txid = tapscript.Tx.util.getTxid( new_post_funding_txhex );
                paul_channels[ "first_channel" ][ "force_close_txs" ][ "other_partys_to_delay_txid" ] = new_tx_commit_txid;
                var new_tx_commit_vout = 0;
                var new_tx_commit_amt = new_post_funding_amt - 500;
                var vickys_address = paul_channels[ "first_channel" ][ "vickys_address" ];
                var new_tx_commit_txdata = tapscript.Tx.create({
                  vin  : [{
                    txid: new_tx_commit_txid,
                    vout: new_tx_commit_vout,
                    //todo: fix this sequence
                    // sequence: 144 * 7,
                    sequence: 1 * 7,
                    prevout: {
                      value: new_tx_commit_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( new_tx_commit_address )
                    },
                  }],
                  vout : []
                });
                var timelock = 8;
                if ( pmthash && amount_paul_will_get > 0 ) {
                    var htlc_script = generateHtlcWherePaulReceives( pauls_key, vickys_key, pmthash, timelock );
                    var htlc_address = tapscript.Address.p2wsh.fromScript( htlc_script, "regtest" );
                    new_tx_commit_txdata[ "vout" ].push({
                        value: new_tx_commit_amt - amount_for_paul - 500,
                        scriptPubKey: tapscript.Address.toScriptPubKey( vickys_address )
                    },{
                        value: amount_for_paul,
                        scriptPubKey: tapscript.Address.toScriptPubKey( htlc_address )
                    });
                }
                if ( pmthash && amount_paul_will_get < 0 ) {
                    var htlc_script = generateHtlcWhereVickyReceives( pauls_key, vickys_key, pmthash, timelock );
                    var htlc_address = tapscript.Address.p2wsh.fromScript( htlc_script, "regtest" );
                    new_tx_commit_txdata[ "vout" ].push({
                        value: new_tx_commit_amt - amount_for_paul - 500,
                        scriptPubKey: tapscript.Address.toScriptPubKey( htlc_address )
                    },{
                        value: amount_for_paul,
                        scriptPubKey: tapscript.Address.toScriptPubKey( pauls_address )
                    });
                }
                if ( !pmthash ) {
                    new_tx_commit_txdata[ "vout" ].push({
                        value: new_tx_commit_amt - amount_for_paul - 500,
                        scriptPubKey: tapscript.Address.toScriptPubKey( vickys_address )
                    },{
                        value: amount_for_paul,
                        scriptPubKey: tapscript.Address.toScriptPubKey( pauls_address )
                    });
                }
                if ( pmthash ) {
                    var new_tx_commit_txhex = tapscript.Tx.encode( new_tx_commit_txdata ).hex;
                    var new_htlc_txid = tapscript.Tx.util.getTxid( new_tx_commit_txhex );
                    if ( preimage ) {
                        var htlc_script = generateHtlcWherePaulReceives( pauls_key, vickys_key, pmthash, timelock );
                        var htlc_address = tapscript.Address.p2wsh.fromScript( htlc_script, "regtest" );
                        var htlc_txdata = tapscript.Tx.create({
                          vin  : [{
                            txid: new_htlc_txid,
                            vout: 1,
                            prevout: {
                              value: amount_for_paul,
                              scriptPubKey: tapscript.Address.toScriptPubKey( htlc_address )
                            },
                          }],
                          vout : [{
                            value: amount_for_paul - 500,
                            scriptPubKey: tapscript.Address.toScriptPubKey( pauls_address )
                          }]
                        });
                        var htlc_sig = tapscript.Signer.segwit.sign( privkey, htlc_txdata, 0, {script: htlc_script} );
                        htlc_txdata.vin[ 0 ].witness = [ htlc_sig, preimage, htlc_script ];
                        var htlc_txhex_if_paul_received_and_vicky_broadcasted = tapscript.Tx.encode( htlc_txdata ).hex;
                    } else {
                        var htlc_script = generateHtlcWhereVickyReceives( pauls_key, vickys_key, pmthash, timelock );
                        var htlc_address = tapscript.Address.p2wsh.fromScript( htlc_script, "regtest" );
                        var htlc_txdata = tapscript.Tx.create({
                          vin  : [{
                            txid: new_htlc_txid,
                            vout: 0,
                            seqence: timelock,
                            prevout: {
                              value: new_tx_commit_amt - amount_for_paul - 500,
                              scriptPubKey: tapscript.Address.toScriptPubKey( htlc_address )
                            },
                          }],
                          vout : [{
                            value: new_tx_commit_amt - amount_for_paul - 500 - 500,
                            scriptPubKey: tapscript.Address.toScriptPubKey( pauls_address )
                          }]
                        });
                        var htlc_sig = tapscript.Signer.segwit.sign( privkey, htlc_txdata, 0, {script: htlc_script} );
                        htlc_txdata.vin[ 0 ].witness = [ htlc_sig, "ab".repeat( 32 ), htlc_script ];
                        var htlc_txhex_if_vicky_received_and_vicky_broadcasted = tapscript.Tx.encode( htlc_txdata ).hex;
                    }
                }
                if ( pmthash && htlc_txhex_if_paul_received_and_vicky_broadcasted ) new_state[ "htlc_txhex_if_paul_received_and_vicky_broadcasted" ] = htlc_txhex_if_paul_received_and_vicky_broadcasted;
                if ( pmthash && htlc_txhex_if_vicky_received_and_vicky_broadcasted ) paul_channels[ "first_channel" ][ "force_close_txs" ][ "htlc_txhex_if_vicky_received_and_vicky_broadcasted" ] = htlc_txhex_if_vicky_received_and_vicky_broadcasted;
                var new_tx_commit_pauls_sig_vicky = tapscript.Signer.taproot.sign( privkey, new_tx_commit_txdata, 0, { extension: tapscript.Tap.encodeScript( new_tx_commit_scripts[ 1 ] ) });
                var channel_identifier = "first_channel";
                var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length;
                var msgnum = 25;
                var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${new_tx_funding_pauls_sig_vicky.hex}${new_post_funding_pauls_sig_vicky.hex}${new_tx_commit_pauls_sig_vicky.hex}`;
                var msghash = await sha256( msg_to_sign );
                var sig = await nobleSecp256k1.sign( msghash, privkey );
                console.log( `give this data to Vicky: ${ JSON.stringify( [ msgnum, channel_identifier, sig, new_tx_funding_pauls_sig_vicky.hex, new_post_funding_pauls_sig_vicky.hex, new_tx_commit_pauls_sig_vicky.hex] ) }`);
                alert( `Send the info in your console to Vicky` );
                var vickys_data = prompt( `enter Vicky's revocation preimage for state ${paul_channels[ "first_channel" ][ "old_states" ].length - 1}` );
                vickys_data = JSON.parse( vickys_data );
                var channel_identifier = vickys_data[ 1 ];
                var vickys_key = paul_channels[ channel_identifier ][ "vickys_key" ];
                var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length;
                var msgnum = 30;
                var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${vickys_data[ 3 ]}`;
                var msghash = await sha256( msg_to_sign );
                var sig = vickys_data[ 2 ];
                var sig_is_valid = await nobleSecp256k1.verify( sig, msghash, vickys_key );
                //todo: automate the force close
                if ( !sig_is_valid ) return alert( `Something went wrong with message 30! Time to force close!` );
                var vickys_revocation_preimage = vickys_data[ 3 ];
                var vickys_revocation_hash = paul_channels[ "first_channel" ][ "old_states" ][ paul_channels[ "first_channel" ][ "old_states" ].length - 1 ][ "vickys_revocation_hash" ];
                if ( rmd160( hexToBytes( vickys_revocation_preimage ) ) != vickys_revocation_hash ) return alert( `Time to force close! Vicky sent you a wrong revocation preimage! Broadcast these transactions:\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "to_reveal" ]}\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "to_delay" ]}\n\nThen wait 1008 blocks, then broadcast this transaction:\n\n${paul_channels[ "first_channel" ][ "force_close_txs" ][ "final_tx" ]}` );
                paul_channels[ "first_channel" ][ "old_states" ][ paul_channels[ "first_channel" ][ "old_states" ].length - 1 ][ "vickys_revocation_preimage" ] = vickys_revocation_preimage;
                var channel_identifier = "first_channel";
                var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length;
                var msgnum = 35;
                var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${paul_channels[ channel_identifier ][ "old_states" ][ paul_channels[ channel_identifier ][ "old_states" ].length - 1 ][ "pauls_revocation_preimage" ]}`;
                var msghash = await sha256( msg_to_sign );
                var sig = await nobleSecp256k1.sign( msghash, privkey );
                console.log( `Send this revocation preimage to Vicky: ${JSON.stringify( [ msgnum, channel_identifier, sig, paul_channels[ channel_identifier ][ "old_states" ][ paul_channels[ channel_identifier ][ "old_states" ].length - 1 ][ "pauls_revocation_preimage" ] ] )}` );
                alert( `send Vicky your revocation preimage (it is in your console)` );
            }
        </script>
    </head>
    <body>
        <h1>Hi Paul</h1>
        <script>
            var paul_channels = {"first_channel": {}}
            var createChannel = async () => {
                var refund_cblock = null;
                var privkey = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                var pauls_key = nobleSecp256k1.getPublicKey( privkey, true );
                var publication_privkey = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                var pauls_publication_preimage = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                var pauls_publication_hash = rmd160( hexToBytes( pauls_publication_preimage ) );
                var pauls_revocation_preimage = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                var pauls_revocation_hash = rmd160( hexToBytes( pauls_revocation_preimage ) );
                var revocation_privkey = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                //to create the message to sign, concatenate the following items, then hash the result: channel identifier, state you are transitioning to (e.g. 0, 1, 2, etc.), message number, all items after the signature itself
                var channel_identifier = "first_channel";
                var transitioning_to = 0;
                var msgnum = 0;
                var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${pauls_key}${pauls_publication_hash}${pauls_revocation_hash}`;
                var msghash = await sha256( msg_to_sign );
                var sig = await nobleSecp256k1.sign( msghash, privkey );
                console.log( "send this to Vicky:", JSON.stringify( [ msgnum, channel_identifier, sig, pauls_key, pauls_publication_hash, pauls_revocation_hash ] ) );
                alert( `send Vicky your key, publication hash, and revocation hash (they are in your console -- if you don't see them there, refresh your page repeatedly til you do)` );
                var data_from_vicky = prompt( `enter the info from Vicky` );
                data_from_vicky = JSON.parse( data_from_vicky );
                var prefunding_txid = data_from_vicky[ 3 ][ "prefunding_txid" ];
                var prefunding_vout = data_from_vicky[ 3 ][ "prefunding_vout" ];
                var prefunding_amt = data_from_vicky[ 3 ][ "prefunding_amt" ];
                var vickys_key = data_from_vicky[ 3 ][ "vickys_key" ];
                var vickys_publication_hash = data_from_vicky[ 3 ][ "vickys_publication_hash" ];
                var vickys_revocation_hash = data_from_vicky[ 3 ][ "vickys_revocation_hash" ];
                var vickys_address = data_from_vicky[ 3 ][ "vickys_address" ];
                var prefunding_address = data_from_vicky[ 3 ][ "prefunding_address" ];
                var channel_identifier = data_from_vicky[ 1 ];
                var transitioning_to = 0;
                var msgnum = 1;
                var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${JSON.stringify(data_from_vicky[ 3 ])}`;
                var msghash = await sha256( msg_to_sign );
                var sig = data_from_vicky[ 2 ];
                var sig_is_valid = await nobleSecp256k1.verify( sig, msghash, vickys_key );
                if ( !sig_is_valid ) return;
                //todo: fix the sequence which should be 144 * 7 not 1 * 7
                var refund_scripts = [
                    [ 'OP_RIPEMD160', vickys_publication_hash, 'OP_EQUALVERIFY', 'OP_RIPEMD160', vickys_revocation_hash, 'OP_EQUALVERIFY', pauls_key.substring( 2 ), 'OP_CHECKSIG' ],
                    [ 0, pauls_key.substring( 2 ), 'OP_CHECKSIGADD', vickys_key.substring( 2 ), 'OP_CHECKSIGADD', 2, 'OP_EQUALVERIFY', 1 * 7, 'OP_CHECKSEQUENCEVERIFY', 'OP_0NOTEQUAL' ],
                    [ 'OP_RIPEMD160', pauls_publication_hash, 'OP_EQUALVERIFY', 'OP_RIPEMD160', pauls_revocation_hash, 'OP_EQUALVERIFY', vickys_key.substring( 2 ), 'OP_CHECKSIG' ]
                ];
                var refund_tree = refund_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                var [ refund_tpubkey, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: refund_tree });
                refund_cblock = cblock;
                var refund_address = tapscript.Address.p2tr.fromPubKey( refund_tpubkey, 'regtest' );
                var tx_funding_script = [
                    2,
                    pauls_key,
                    vickys_key,
                    2,
                    'OP_CHECKMULTISIG'
                ];
                var tx_funding_address = tapscript.Address.p2wsh.fromScript( tx_funding_script, "regtest" );
                var post_funding_script_paul = [
                    'OP_RIPEMD160',
                    pauls_publication_hash,
                    'OP_EQUAL',
                    'OP_NOTIF',
                        'OP_10',
                        'OP_CHECKSEQUENCEVERIFY',
                        'OP_DROP',
                    'OP_ENDIF',
                    2,
                    pauls_key,
                    vickys_key,
                    2,
                    'OP_CHECKMULTISIG'
                ];
                // var tx_funding_script = [ 2, pauls_key, vickys_key, 2, 'OP_CHECKMULTISIG' ];
                var post_funding_address_paul = tapscript.Address.p2wsh.fromScript( post_funding_script_paul, "regtest" );
                var post_funding_script_vicky = [
                    'OP_RIPEMD160',
                    vickys_publication_hash,
                    'OP_EQUAL',
                    'OP_IF',
                        2,
                        pauls_key,
                        vickys_key,
                        2,
                        'OP_CHECKMULTISIG',
                    'OP_ELSE',
                        'OP_10',
                        'OP_CHECKSEQUENCEVERIFY',
                        'OP_DROP',
                        pauls_key,
                        'OP_CHECKSIG',
                    'OP_ENDIF',
                ];
                // var tx_funding_script = [ 2, pauls_key, vickys_key, 2, 'OP_CHECKMULTISIG' ];
                var post_funding_address_vicky = tapscript.Address.p2wsh.fromScript( post_funding_script_vicky, "regtest" );
                var prefunding_txdata = tapscript.Tx.create({
                  vin  : [{
                    txid: prefunding_txid,
                    vout: prefunding_vout,
                    prevout: {
                      value: prefunding_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( prefunding_address )
                    },
                  }],
                  vout : [{
                    value: prefunding_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( tx_funding_address )
                  }]
                });
                var prefunding_txhex = tapscript.Tx.encode( prefunding_txdata ).hex;
                var tx_funding_txid = tapscript.Tx.util.getTxid( prefunding_txhex );
                var tx_funding_vout = 0;
                var tx_funding_amt = prefunding_amt - 500;
                var tx_funding_txdata_paul = tapscript.Tx.create({
                  vin  : [{
                    txid: tx_funding_txid,
                    vout: tx_funding_vout,
                    prevout: {
                      value: tx_funding_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( tx_funding_address )
                    },
                  }],
                  vout : [{
                    value: tx_funding_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( post_funding_address_paul )
                  }]
                });
                var sighash = tapscript.Signer.segwit.hash( tx_funding_txdata_paul, 0, { script: tx_funding_script } );
                var tx_funding_pauls_sig = tapscript.Signer.segwit.sign( privkey, tx_funding_txdata_paul, 0, { script: tx_funding_script });
                tx_funding_txdata_paul.vin[ 0 ].witness = [ 0, 0, tx_funding_pauls_sig, tx_funding_script ];
                var tx_funding_txhex_paul = tapscript.Tx.encode( tx_funding_txdata_paul ).hex;
                var post_funding_txid = tapscript.Tx.util.getTxid( tx_funding_txhex_paul );
                var post_funding_vout = 0;
                var post_funding_amt = tx_funding_amt - 500;
                var post_funding_txdata_paul = tapscript.Tx.create({
                  vin  : [{
                    txid: post_funding_txid,
                    vout: post_funding_vout,
                    prevout: {
                      value: post_funding_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( post_funding_address_paul )
                    },
                  }],
                  vout : [{
                    value: post_funding_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( refund_address )
                  }]
                });
                var post_funding_pauls_sig = tapscript.Signer.segwit.sign( privkey, post_funding_txdata_paul, 0, { script: post_funding_script_paul });
                var post_funding_txhex_paul = tapscript.Tx.encode( post_funding_txdata_paul ).hex;
                var tx_refund_txid = tapscript.Tx.util.getTxid( post_funding_txhex_paul );
                var tx_refund_vout = 0;
                var tx_refund_amt = post_funding_amt - 500;
                var tx_refund_txdata_paul = tapscript.Tx.create({
                  vin  : [{
                    txid: tx_refund_txid,
                    vout: tx_refund_vout,
                    //todo: fix the sequence
                    // sequence: 144 * 7,
                    sequence: 1 * 7,
                    prevout: {
                      value: tx_refund_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( refund_address )
                    },
                  }],
                  vout : [{
                    value: tx_refund_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( vickys_address )
                  }]
                });
                var tx_refund_pauls_sig = tapscript.Signer.taproot.sign( privkey, tx_refund_txdata_paul, 0, { extension: tapscript.Tap.encodeScript( refund_scripts[ 1 ] ) });
                //the following sig should move the money from the refund address to vicky
                tx_refund_txdata_paul.vin[ 0 ].witness = [ 0, tx_refund_pauls_sig, refund_scripts[ 1 ], refund_cblock ];
                var tx_refund_txhex = tapscript.Tx.encode( tx_refund_txdata_paul ).hex;
                //versions for vicky
                var tx_funding_txdata_vicky = tapscript.Tx.create({
                  vin  : [{
                    txid: tx_funding_txid,
                    vout: tx_funding_vout,
                    prevout: {
                      value: tx_funding_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( tx_funding_address )
                    },
                  }],
                  vout : [{
                    value: tx_funding_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( post_funding_address_vicky )
                  }]
                });
                var tx_funding_pauls_sig_vicky = tapscript.Signer.segwit.sign( privkey, tx_funding_txdata_vicky, 0, { script: tx_funding_script });
                tx_funding_txdata_vicky.vin[ 0 ].witness = [ 0, 0, tx_funding_pauls_sig_vicky, tx_funding_script ];
                var tx_funding_txhex_vicky = tapscript.Tx.encode( tx_funding_txdata_vicky ).hex;
                var post_funding_txid = tapscript.Tx.util.getTxid( tx_funding_txhex_vicky );
                var other_partys_to_reveal_txid = post_funding_txid;
                var post_funding_vout = 0;
                var post_funding_amt = tx_funding_amt - 500;
                var post_funding_txdata_vicky = tapscript.Tx.create({
                  vin  : [{
                    txid: post_funding_txid,
                    vout: post_funding_vout,
                    prevout: {
                      value: post_funding_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( post_funding_address_vicky )
                    },
                  }],
                  vout : [{
                    value: post_funding_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( refund_address )
                  }]
                });
                var post_funding_pauls_sig_vicky = tapscript.Signer.segwit.sign( privkey, post_funding_txdata_vicky, 0, { script: post_funding_script_vicky });
                var post_funding_txhex_vicky = tapscript.Tx.encode( post_funding_txdata_vicky ).hex;
                var tx_refund_txid = tapscript.Tx.util.getTxid( post_funding_txhex_vicky );
                var other_partys_to_delay_txid = tx_refund_txid;
                var tx_refund_vout = 0;
                var tx_refund_amt = post_funding_amt - 500;
                var tx_refund_txdata_vicky = tapscript.Tx.create({
                  vin  : [{
                    txid: tx_refund_txid,
                    vout: tx_refund_vout,
                    //todo: fix the sequence
                    // sequence: 144 * 7,
                    sequence: 1 * 7,
                    prevout: {
                      value: tx_refund_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( refund_address )
                    },
                  }],
                  vout : [{
                    value: tx_refund_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( vickys_address )
                  }]
                });
                //the following sig should move the money from the refund address to vicky
                var tx_refund_pauls_sig_vicky = tapscript.Signer.taproot.sign( privkey, tx_refund_txdata_vicky, 0, { extension: tapscript.Tap.encodeScript( refund_scripts[ 1 ] ) });
                var channel_identifier = "first_channel";
                var transitioning_to = 0;
                var msgnum = 2;
                var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${tx_funding_pauls_sig_vicky.hex}${post_funding_pauls_sig_vicky.hex}${tx_refund_pauls_sig_vicky.hex}`;
                var msghash = await sha256( msg_to_sign );
                var sig = await nobleSecp256k1.sign( msghash, privkey );
                var pauls_sigs = [ msgnum, channel_identifier, sig, tx_funding_pauls_sig_vicky.hex, post_funding_pauls_sig_vicky.hex, tx_refund_pauls_sig_vicky.hex ];
                console.log( `give these sigs to Vicky: ${JSON.stringify( pauls_sigs )}` );
                paul_channels[ "first_channel" ][ "force_close_txs" ] = {
                    other_partys_to_reveal_txid,
                    other_partys_to_delay_txid,
                    to_reveal: tx_funding_txhex_paul,
                    to_delay: post_funding_txhex_paul,
                    final_tx: tx_refund_txhex,
                    vickys_publication_hash,
                    vickys_revocation_hash,
                    pauls_publication_preimage,
                    pauls_revocation_preimage,
                }
                paul_channels[ "first_channel" ][ "tx_funding_amt" ] = tx_funding_amt;
                paul_channels[ "first_channel" ][ "tx_funding_address" ] = tx_funding_address;
                paul_channels[ "first_channel" ][ "tx_funding_script" ] = tx_funding_script;
                paul_channels[ "first_channel" ][ "vickys_key" ] = vickys_key;
                paul_channels[ "first_channel" ][ "vickys_address" ] = vickys_address;
                paul_channels[ "first_channel" ][ "balance" ] = {
                    reserve: 0,
                    local: 0,
                    remote: tx_refund_amt - 500,
                }
                paul_channels[ "first_channel" ][ "privkey" ] = privkey;
                paul_channels[ "first_channel" ][ "pauls_key" ] = pauls_key;
                alert( `Send the data in your console to Vicky` );
            }
            setTimeout( createChannel, 100 );
        </script>
    </body>
</html>
