<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, user-scalable=no">
        <script src="https://unpkg.com/@cmdcode/tapscript@1.4.3"></script>
        <script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
        <script src="https://unpkg.com/@dashincubator/ripemd160/ripemd160.js"></script>
        <script src="https://bundle.run/browserify-cipher@1.0.1"></script>
        <script>
            function hexToBytes( hex ) {
                return Uint8Array.from( hex.match( /.{1,2}/g ).map( ( byte ) => parseInt( byte, 16 ) ) );
            }

            function bytesToHex( bytes ) {
                return bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, "0" ), "" );
            }
            function base64ToHex( str ) {
                var raw = atob( str );
                var result = '';
                var i; for ( i=0; i<raw.length; i++ ) {
                    var hex = raw.charCodeAt( i ).toString( 16 );
                    result += ( hex.length === 2 ? hex : '0' + hex );
                }
                return result;
            }
            var rmd160 = s => {
                if ( typeof s == "string" ) s = new TextEncoder().encode( s );
                var hash = RIPEMD160.create();
                hash.update( new Uint8Array( s ) );
                return bytesToHex( hash.digest() );
            }
            var sha256 = s => {
                if ( typeof s == "string" ) s = new TextEncoder().encode( s );
                return crypto.subtle.digest( 'SHA-256', s ).then( hashBuffer => {
                    var hashArray = Array.from( new Uint8Array( hashBuffer ) );
                    var hashHex = hashArray
                        .map( bytes => bytes.toString( 16 ).padStart( 2, '0' ) )
                        .join( '' );
                    return hashHex;
                });
            }
        </script>
        <style>
            * {
                box-sizing: border-box;
                font-size: 1.15rem;
                font-family: Arial, sans-serif;
            }
            html {
                max-width: 70ch;
                padding: 3rem 1rem;
                margin: auto;
                line-height: 1.25;
            }
            h1 {
                font-size: 2rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            input {
                line-height: 1.25;
                width: 100%;
                height: 1.8rem;
                font-size: 1.15rem;
                border: 1px solid grey;
            }
            .toast {
              box-sizing: border-box;
              visibility: hidden; /* Hidden by default. Visible on click */
              width: 250px; /* Set a default minimum width */
              margin-left: -125px; /* Divide value of min-width by 2 */
              background-color: lightgreen; /* Blue background color */
              color: white; /* White text color */
              text-align: center; /* Centered text */
              border-radius: 2px; /* Rounded borders */
              padding: 16px; /* Padding */
              position: fixed; /* Sit on top of the screen */
              z-index: 1; /* Add a z-index if needed */
              left: 50%; /* Center the toast */
              bottom: 30px; /* 30px from the bottom */
            }
            /* Show the toast when clicking on a button (class added with JavaScript) */
            .toast.show {
              visibility: visible; /* Show the toast */
              /* Add animation: Take 0.5 seconds to fade in and out the toast.
              However, delay the fade out process for 2.5 seconds */
              -webkit-animation: fadein 0.5s, fadeout 0.5s 2.5s;
              animation: fadein 0.5s, fadeout 0.5s 2.5s;
            }
            /* Animations to fade the toast in and out */
            @-webkit-keyframes fadein {
              from {bottom: 0; opacity: 0;}
              to {bottom: 30px; opacity: 1;}
            }
            @keyframes fadein {
              from {bottom: 0; opacity: 0;}
              to {bottom: 30px; opacity: 1;}
            }
            @-webkit-keyframes fadeout {
              from {bottom: 30px; opacity: 1;}
              to {bottom: 0; opacity: 0;}
            }
            @keyframes fadeout {
              from {bottom: 30px; opacity: 1;}
              to {bottom: 0; opacity: 0;}
            }
            @media screen and (max-width: 600px) {
            }
        </style>
        <script>
            var $ = document.querySelector.bind( document );
            var $$ = document.querySelectorAll.bind( document );
            var url_params = new URLSearchParams( window.location.search );
            var url_keys = url_params.keys();
            var $_GET = {}
            for ( var key of url_keys ) $_GET[ key ] = url_params.get( key );
        </script>
        <script>
            var getRand = size => bytesToHex(crypto.getRandomValues(new Uint8Array(size)));
            var changeStateWithHtlc = async channel_identifier => {
                var am_sending = confirm( `Click ok if you are sending or cancel if you are receiving` );
                var privkey = paul_channels[ channel_identifier ][ "privkey" ];
                var pauls_key = paul_channels[ channel_identifier ][ "pauls_key" ];
                var vickys_key = paul_channels[ channel_identifier ][ "vickys_key" ];
                if ( am_sending ) {
                    //todo: use more relays
                    var msgnum = 6;
                    alert( `Hit ok when your counterparty sent message ${msgnum}` );
                    var msg_from_counterparty = await getDMs( [ pauls_key.substring( 2 ) ], "wss://nostrue.com" );
                    try {
                        var vickys_data = decrypt( privkey, msg_from_counterparty.pubkey, msg_from_counterparty.content );
                    } catch( e ) {
                        //todo: automate the force close
                        return alert( `Your counterparty stopped responding during a state update! Time to force close` );
                    }
                    console.log( `Got message ${msgnum}`, vickys_data );
                    // var vickys_data = prompt( `enter the data from Vicky` );
                    vickys_data = JSON.parse( vickys_data );
                    var pmthash = vickys_data[ 3 ];
                    var channel_identifier = vickys_data[ 1 ];
                    if ( !( "old_states" in paul_channels[ channel_identifier ] ) ) paul_channels[ channel_identifier ][ "old_states" ] = [];
                    var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length;
                    var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${pmthash}`;
                    var msghash = await sha256( msg_to_sign );
                    var sig = vickys_data[ 2 ];
                    var sig_is_valid = await nobleSecp256k1.verify( sig, msghash, vickys_key );
                    if ( !sig_is_valid ) return;
                } else {
                    var amt = prompt( `How many sats do you want Vicky to send you? Must be less than ${paul_channels[ channel_identifier ][ "balance" ][ "remote" ]} sats` );
                    amt = Number( amt );
                    var preimage = getRand( 32 );
                    var pmthash = await sha256( hexToBytes( preimage ) );
                    if ( !( "old_states" in paul_channels[ channel_identifier ] ) ) paul_channels[ channel_identifier ][ "old_states" ] = [];
                    var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length;
                    var msgnum = 5;
                    var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${pmthash}${amt}`;
                    var msghash = await sha256( msg_to_sign );
                    var sig = await nobleSecp256k1.sign( msghash, privkey );
                    // console.log( "send this to Vicky:", JSON.stringify( [ msgnum, channel_identifier, sig, pmthash, amt ] ) );
                    //todo: use more relays
                    alert( `Hit ok to send msg ${msgnum}` );
                    await sendDM( JSON.stringify( [ msgnum, channel_identifier, sig, pmthash, amt ] ), vickys_key.substring( 2 ), "wss://nostrue.com", pauls_key.substring( 2 ), privkey, msgnum );
                    showToast( `sent message ${msgnum}` );
                    await waitSomeSeconds( 2 );
                    console.log( `sent message ${msgnum}` );
                }
                if ( !am_sending ) {
                    await changeState( channel_identifier, pmthash, preimage, 0, amt );
                    var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length;
                    var msgnum = 40;
                    var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${preimage}`;
                    var msghash = await sha256( msg_to_sign );
                    var sig = await nobleSecp256k1.sign( msghash, privkey );
                    // console.log( `send this info to Vicky: ${JSON.stringify( [ msgnum, channel_identifier, sig, preimage ] )}` );
                    //todo: use more relays
                    alert( `Hit ok to send msg ${msgnum}\n\nSEND ME FIRST` );
                    await sendDM( JSON.stringify( [ msgnum, channel_identifier, sig, preimage ] ), vickys_key.substring( 2 ), "wss://nostrue.com", pauls_key.substring( 2 ), privkey, msgnum );
                    showToast( `sent message ${msgnum}` );
                    await waitSomeSeconds( 2 );
                    console.log( `sent message ${msgnum}` );
                } else {
                    await changeState( channel_identifier, pmthash, preimage );
                    //todo: use more relays
                    var msgnum = 45;
                    alert( `Hit ok when your counterparty sent message ${msgnum}` );
                    var msg_from_counterparty = await getDMs( [ pauls_key.substring( 2 ) ], "wss://nostrue.com" );
                    try {
                        var vickys_info = decrypt( privkey, msg_from_counterparty.pubkey, msg_from_counterparty.content );
                    } catch( e ) {
                        //todo: automate the force close
                        return alert( `Your counterparty stopped responding during a state update! Time to force close` );
                    }
                    console.log( `Got message ${msgnum}`, vickys_info );
                    // var vickys_info = prompt( `enter a preimage from Vicky` );
                    vickys_info = JSON.parse( vickys_info );
                    var preimage = vickys_info[ 3 ];
                    var channel_identifier = vickys_info[ 1 ];
                    var vickys_key = paul_channels[ channel_identifier ][ "vickys_key" ];
                    var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length;
                    var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${preimage}`;
                    var msghash = await sha256( msg_to_sign );
                    var sig = vickys_info[ 2 ];
                    var sig_is_valid = await nobleSecp256k1.verify( sig, msghash, vickys_key );
                    //todo: automate the force close
                    if ( !sig_is_valid ) return alert( `Something went wrong with the preimage! Time to force close` );
                }
                var resolve_htlc = true;
                var real_pmthash = await sha256( hexToBytes( preimage ) );
                var claimed_pmthash = paul_channels[ channel_identifier ][ "force_close_txs" ][ "pmthash" ];
                //todo: automate the force close
                if ( real_pmthash != claimed_pmthash ) return alert( `Oh no! Your counterparty gave you a bad preimage! Time to force close!` );
                changeState( channel_identifier, "", preimage, resolve_htlc );
            }
            function generateHtlcWherePaulReceives(paulPubkey, vickyPubkey, pmthash, timelock) {
                return [
                    'OP_SIZE',
                    32,
                    'OP_EQUALVERIFY',
                    'OP_SHA256',
                    pmthash,
                    'OP_EQUAL',
                    'OP_IF',
                        paulPubkey,
                    'OP_ELSE',
                        timelock,
                        'OP_CHECKSEQUENCEVERIFY',
                        'OP_DROP',
                        vickyPubkey,
                    'OP_ENDIF',
                    'OP_CHECKSIG'
                ];
            }
            function generateHtlcWhereVickyReceives(paulPubkey, vickyPubkey, pmthash, timelock) {
                return [
                    'OP_SIZE',
                    32,
                    'OP_EQUALVERIFY',
                    'OP_SHA256',
                    pmthash,
                    'OP_EQUAL',
                    'OP_IF',
                        vickyPubkey,
                    'OP_ELSE',
                        timelock,
                        'OP_CHECKSEQUENCEVERIFY',
                        'OP_DROP',
                        paulPubkey,
                    'OP_ENDIF',
                    'OP_CHECKSIG'
                ];
            }
            var mempool_checker = ( txid, channel_identifier ) => {
                var txhex = prompt( `Please enter the txhex of a tx with this txid: ${txid}` );
                var tx = tapscript.Tx.decode( txhex );
                var witness_stack = tx.vin[ 0 ].witness;
                var vickys_publication_preimage = witness_stack[ 3 ];
                var vickys_revocation_preimage = null;
                var pauls_publication_preimage = null;
                var pauls_revocation_preimage = null;
                var vickys_address = paul_channels[ channel_identifier ][ "vickys_address" ];
                var pauls_address = paul_channels[ channel_identifier ][ "pauls_address" ];
                var vickys_key = paul_channels[ channel_identifier ][ "vickys_key" ];
                var pauls_key = paul_channels[ channel_identifier ][ "pauls_key" ];
                var privkey = paul_channels[ channel_identifier ][ "privkey" ];
                //todo: also check if this is the to_reveal tx, in which case
                //you don't need to look for a preimage, just prepare a justice
                //tx and broadcast it after waiting 10 blocks
                paul_channels[ channel_identifier ][ "old_states" ].every( ( item, index ) => {
                    var old_state_txid = item[ "other_partys_to_delay_txid" ];
                    if ( old_state_txid == txid ) {
                        if ( "vickys_revocation_preimage" in item ) vickys_revocation_preimage = item[ "vickys_revocation_preimage" ];
                        pauls_publication_preimage = item[ "pauls_publication_preimage" ];
                        pauls_revocation_preimage = item[ "pauls_revocation_preimage" ];
                        return;
                    }
                    return true;
                });
                if ( !vickys_revocation_preimage ) return;
                var justice_txdata = tapscript.Tx.create({
                  vin  : [{
                    txid: txid,
                    vout: 0,
                    prevout: {
                      value: Number( tx.vout[ 0 ].value ),
                      scriptPubKey: tx.vout[ 0 ].scriptPubKey
                    },
                  }],
                  vout : [{
                    value: Number( tx.vout[ 0 ].value ) - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( pauls_address )
                  }]
                });
                var justice_scripts = [
                    [ 'OP_RIPEMD160', rmd160( hexToBytes( vickys_publication_preimage ) ), 'OP_EQUALVERIFY', 'OP_RIPEMD160', rmd160( hexToBytes( vickys_revocation_preimage ) ), 'OP_EQUALVERIFY', pauls_key.substring( 2 ), 'OP_CHECKSIG' ],
                    [ 0, pauls_key.substring( 2 ), 'OP_CHECKSIGADD', vickys_key.substring( 2 ), 'OP_CHECKSIGADD', 2, 'OP_EQUALVERIFY', 1 * 7, 'OP_CHECKSEQUENCEVERIFY', 'OP_0NOTEQUAL' ],
                    [ 'OP_RIPEMD160', rmd160( hexToBytes( pauls_publication_preimage ) ), 'OP_EQUALVERIFY', 'OP_RIPEMD160', rmd160( hexToBytes( pauls_revocation_preimage ) ), 'OP_EQUALVERIFY', vickys_key.substring( 2 ), 'OP_CHECKSIG' ],
                ];
                var justice_tree = justice_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                var [ justice_tpubkey, justice_cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: justice_tree, target: tapscript.Tap.encodeScript( justice_scripts[ 0 ] ) });
                var sig = tapscript.Signer.taproot.sign( privkey, justice_txdata, 0, { extension: tapscript.Tap.encodeScript( justice_scripts[ 0 ] ) });
                //the order of the witness stack is: publication preimage furthest "forward", revocation preimage next "back", sig furthest back
                justice_txdata.vin[ 0 ].witness = [ sig.hex, vickys_revocation_preimage, vickys_publication_preimage, justice_scripts[ 0 ], justice_cblock ];
                var justice_txhex = tapscript.Tx.encode( justice_txdata ).hex;
            }
            var changeState = async ( channel_identifier, pmthash, preimage, resolve_htlc, amount_paul_wants ) => {
                var pauls_key = paul_channels[ channel_identifier ][ "pauls_key" ];
                var vickys_key = paul_channels[ channel_identifier ][ "vickys_key" ];
                var privkey = paul_channels[ channel_identifier ][ "privkey" ];
                if ( resolve_htlc ) var expected_amount_for_paul = paul_channels[ channel_identifier ][ "tx_funding_amt" ] + 500 - paul_channels[ channel_identifier ][ "balance" ][ "remote" ];
                var pauls_new_publication_preimage = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                var pauls_new_publication_hash = rmd160( hexToBytes( pauls_new_publication_preimage ) );
                var pauls_new_revocation_preimage = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                var pauls_new_revocation_hash = rmd160( hexToBytes( pauls_new_revocation_preimage ) );
                //todo: use more relays
                var msgnum = 10;
                alert( `Hit ok when your counterparty sent message ${msgnum}` );
                var msg_from_counterparty = await getDMs( [ pauls_key.substring( 2 ) ], "wss://nostrue.com" );
                try {
                    var vickys_data = decrypt( privkey, msg_from_counterparty.pubkey, msg_from_counterparty.content );
                } catch( e ) {
                    //todo: automate the force close
                    return alert( `Your counterparty stopped responding during a state update! Time to force close` );
                }
                console.log( `Got message ${msgnum}`, vickys_data );
                // var vickys_data = prompt( `enter Vicky's new pub & rev hashes & amount` );
                vickys_data = JSON.parse( vickys_data );
                var vickys_new_publication_hash = vickys_data[ 3 ];
                var vickys_new_revocation_hash = vickys_data[ 4 ];
                var amount_for_paul = vickys_data[ 5 ];
                var channel_identifier = vickys_data[ 1 ];
                var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length + 1;
                var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${vickys_new_publication_hash}${vickys_new_revocation_hash}${amount_for_paul}`;
                var msghash = await sha256( msg_to_sign );
                var sig = vickys_data[ 2 ];
                var sig_is_valid = await nobleSecp256k1.verify( sig, msghash, vickys_key );
                //todo: automate the force close
                if ( !sig_is_valid ) return alert( `Something went wrong with message 10! Time to force close!` );
                if ( expected_amount_for_paul && expected_amount_for_paul != expected_amount_for_paul ) return alert( `Oh no, they tried to send you the wrong amount! Time to force close` );
                if ( amount_for_paul > paul_channels[ channel_identifier ][ "tx_funding_amt" ] + 500 ) return;
                //don't send money to Vicky if you don't have a sufficient reserve built up yet
                if ( amount_for_paul <= paul_channels[ channel_identifier ][ "balance" ][ "reserve" ] ) return;
                var amount_paul_currently_has = paul_channels[ channel_identifier ][ "balance" ][ "local" ] + paul_channels[ channel_identifier ][ "balance" ][ "reserve" ];
                var amount_paul_will_get = amount_for_paul - amount_paul_currently_has;
                if ( amount_paul_will_get == 0 && !resolve_htlc ) return;
                if ( amount_paul_will_get > 0 ) var msg = `Do you want Vicky to send you ${amount_paul_will_get} sats?`;
                else var msg = `Do you want to send Vicky ${Math.abs( amount_paul_will_get )} sats?`;
                if ( amount_paul_will_get == 0 && resolve_htlc || amount_paul_wants && amount_paul_will_get == amount_paul_wants ) var conf = true;
                else var conf = confirm( msg );
                if ( amount_paul_wants && amount_paul_will_get != amount_paul_wants ) return;
                if ( !conf ) return;
                var new_post_funding_script_paul = [
                    'OP_RIPEMD160',
                    pauls_new_publication_hash,
                    'OP_EQUAL',
                    'OP_IF',
                        2,
                        pauls_key,
                        vickys_key,
                        2,
                        'OP_CHECKMULTISIG',
                    'OP_ELSE',
                        'OP_10',
                        'OP_CHECKSEQUENCEVERIFY',
                        'OP_DROP',
                        vickys_key,
                        'OP_CHECKSIG',
                    'OP_ENDIF',
                ];
                // var tx_funding_script = [ 2, pauls_key, vickys_key, 2, 'OP_CHECKMULTISIG' ];
                var new_post_funding_address_paul = tapscript.Address.p2wsh.fromScript( new_post_funding_script_paul, "regtest" );
                var new_post_funding_script_vicky = [
                    'OP_RIPEMD160',
                    vickys_new_publication_hash,
                    'OP_EQUAL',
                    'OP_IF',
                        2,
                        pauls_key,
                        vickys_key,
                        2,
                        'OP_CHECKMULTISIG',
                    'OP_ELSE',
                        'OP_10',
                        'OP_CHECKSEQUENCEVERIFY',
                        'OP_DROP',
                        pauls_key,
                        'OP_CHECKSIG',
                    'OP_ENDIF',
                ];
                // var tx_funding_script = [ 2, pauls_key, vickys_key, 2, 'OP_CHECKMULTISIG' ];
                var new_post_funding_address_vicky = tapscript.Address.p2wsh.fromScript( new_post_funding_script_vicky, "regtest" );
                var new_tx_commit_scripts = [
                    [ 'OP_RIPEMD160', vickys_new_publication_hash, 'OP_EQUALVERIFY', 'OP_RIPEMD160', vickys_new_revocation_hash, 'OP_EQUALVERIFY', pauls_key.substring( 2 ), 'OP_CHECKSIG' ],
                    [ 0, pauls_key.substring( 2 ), 'OP_CHECKSIGADD', vickys_key.substring( 2 ), 'OP_CHECKSIGADD', 2, 'OP_EQUALVERIFY', 1 * 7, 'OP_CHECKSEQUENCEVERIFY', 'OP_0NOTEQUAL' ],
                    [ 'OP_RIPEMD160', pauls_new_publication_hash, 'OP_EQUALVERIFY', 'OP_RIPEMD160', pauls_new_revocation_hash, 'OP_EQUALVERIFY', vickys_key.substring( 2 ), 'OP_CHECKSIG' ],
                ];
                var new_tx_commit_tree = new_tx_commit_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                var [ new_tx_commit_tpubkey, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: new_tx_commit_tree, target: tapscript.Tap.encodeScript( new_tx_commit_scripts[ 1 ] ) });
                var new_tx_commit_cblock = cblock;
                var new_tx_commit_address = tapscript.Address.p2tr.fromPubKey( new_tx_commit_tpubkey, 'regtest' );
                var prev_tx_funding = tapscript.Tx.decode( paul_channels[ channel_identifier ][ "force_close_txs" ][ "to_reveal" ] );
                var tx_funding_txid = prev_tx_funding[ "vin" ][ 0 ][ "txid" ];
                var tx_funding_vout = prev_tx_funding[ "vin" ][ 0 ][ "vout" ];
                var tx_funding_amt = paul_channels[ channel_identifier ][ "tx_funding_amt" ];
                var tx_funding_address = paul_channels[ channel_identifier ][ "tx_funding_address" ];
                var tx_funding_script = paul_channels[ channel_identifier ][ "tx_funding_script" ];
                var new_tx_funding_txdata = tapscript.Tx.create({
                  vin  : [{
                    txid: tx_funding_txid,
                    vout: tx_funding_vout,
                    prevout: {
                      value: tx_funding_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( tx_funding_address )
                    },
                  }],
                  vout : [{
                    value: tx_funding_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( new_post_funding_address_paul )
                  }]
                });
                var new_tx_funding_pauls_sig = tapscript.Signer.segwit.sign( privkey, new_tx_funding_txdata, 0, { script: tx_funding_script });
                var new_tx_funding_txhex = tapscript.Tx.encode( new_tx_funding_txdata ).hex;
                var new_post_funding_txid = tapscript.Tx.util.getTxid( new_tx_funding_txhex );
                var new_post_funding_vout = 0;
                var new_post_funding_amt = tx_funding_amt - 500;
                var new_post_funding_txdata = tapscript.Tx.create({
                  vin  : [{
                    txid: new_post_funding_txid,
                    vout: new_post_funding_vout,
                    prevout: {
                      value: new_post_funding_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( new_post_funding_address_paul )
                    },
                  }],
                  vout : [{
                    value: new_post_funding_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( new_tx_commit_address )
                  }]
                });
                var sighash = tapscript.Signer.segwit.hash( new_post_funding_txdata, 0, { script: new_post_funding_script_paul } );
                var new_post_funding_pauls_sig = tapscript.Signer.segwit.sign( privkey, new_post_funding_txdata, 0, { script: new_post_funding_script_paul });
                var new_post_funding_txhex = tapscript.Tx.encode( new_post_funding_txdata ).hex;
                var new_tx_commit_txid = tapscript.Tx.util.getTxid( new_post_funding_txhex );
                var new_tx_commit_vout = 0;
                var new_tx_commit_amt = new_post_funding_amt - 500;
                //todo: get this address from elsewhere
                var pauls_address = 'bcrt1q738hdjlatdx9xmg3679kwq9cwd7fa2c84my9zk';
                paul_channels[ channel_identifier ][ "pauls_address" ] = pauls_address;
                var vickys_address = paul_channels[ channel_identifier ][ "vickys_address" ];
                var new_tx_commit_txdata = tapscript.Tx.create({
                  vin  : [{
                    txid: new_tx_commit_txid,
                    vout: new_tx_commit_vout,
                    //todo: fix this sequence
                    // sequence: 144 * 7,
                    sequence: 1 * 7,
                    prevout: {
                      value: new_tx_commit_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( new_tx_commit_address )
                    },
                  }],
                  vout : []
                });
                var timelock = 8;
                if ( pmthash && amount_paul_will_get > 0 ) {
                    var htlc_script = generateHtlcWherePaulReceives( pauls_key, vickys_key, pmthash, timelock );
                    var htlc_address = tapscript.Address.p2wsh.fromScript( htlc_script, "regtest" );
                    new_tx_commit_txdata[ "vout" ].push({
                        value: new_tx_commit_amt - amount_for_paul - 500,
                        scriptPubKey: tapscript.Address.toScriptPubKey( vickys_address )
                    },{
                        value: amount_for_paul,
                        scriptPubKey: tapscript.Address.toScriptPubKey( htlc_address )
                    });
                }
                if ( pmthash && amount_paul_will_get < 0 ) {
                    var htlc_script = generateHtlcWhereVickyReceives( pauls_key, vickys_key, pmthash, timelock );
                    var htlc_address = tapscript.Address.p2wsh.fromScript( htlc_script, "regtest" );
                    new_tx_commit_txdata[ "vout" ].push({
                        value: new_tx_commit_amt - amount_for_paul - 500,
                        scriptPubKey: tapscript.Address.toScriptPubKey( htlc_address )
                    },{
                        value: amount_for_paul,
                        scriptPubKey: tapscript.Address.toScriptPubKey( pauls_address )
                    });
                }
                if ( !pmthash ) {
                    new_tx_commit_txdata[ "vout" ].push({
                        value: new_tx_commit_amt - amount_for_paul - 500,
                        scriptPubKey: tapscript.Address.toScriptPubKey( vickys_address )
                    },{
                        value: amount_for_paul,
                        scriptPubKey: tapscript.Address.toScriptPubKey( pauls_address )
                    });
                }
                if ( pmthash ) {
                    var new_tx_commit_txhex = tapscript.Tx.encode( new_tx_commit_txdata ).hex;
                    var new_htlc_txid = tapscript.Tx.util.getTxid( new_tx_commit_txhex );
                    if ( preimage ) {
                        var htlc_script = generateHtlcWherePaulReceives( pauls_key, vickys_key, pmthash, timelock );
                        var htlc_address = tapscript.Address.p2wsh.fromScript( htlc_script, "regtest" );
                        var htlc_txdata = tapscript.Tx.create({
                          vin  : [{
                            txid: new_htlc_txid,
                            vout: 1,
                            prevout: {
                              value: amount_for_paul,
                              scriptPubKey: tapscript.Address.toScriptPubKey( htlc_address )
                            },
                          }],
                          vout : [{
                            value: amount_for_paul - 500,
                            scriptPubKey: tapscript.Address.toScriptPubKey( pauls_address )
                          }]
                        });
                        var htlc_sig = tapscript.Signer.segwit.sign( privkey, htlc_txdata, 0, {script: htlc_script} );
                        var sighash = tapscript.Signer.segwit.hash( htlc_txdata, 0, { script: htlc_script } );
                        var sig_is_good = await nobleSecp256k1.verify( htlc_sig.hex.substring( 0, htlc_sig.hex.length - 2 ), sighash.hex, pauls_key );
                        htlc_txdata.vin[ 0 ].witness = [ htlc_sig, preimage, htlc_script ];
                        var htlc_txhex_if_paul_received_and_paul_broadcasted = tapscript.Tx.encode( htlc_txdata ).hex;
                    } else {
                        var htlc_script = generateHtlcWhereVickyReceives( pauls_key, vickys_key, pmthash, timelock );
                        var htlc_address = tapscript.Address.p2wsh.fromScript( htlc_script, "regtest" );
                        var htlc_txdata = tapscript.Tx.create({
                          vin  : [{
                            txid: new_htlc_txid,
                            vout: 0,
                            seqence: timelock,
                            prevout: {
                              value: new_tx_commit_amt - amount_for_paul - 500,
                              scriptPubKey: tapscript.Address.toScriptPubKey( htlc_address )
                            },
                          }],
                          vout : [{
                            value: new_tx_commit_amt - amount_for_paul - 500 - 500,
                            scriptPubKey: tapscript.Address.toScriptPubKey( pauls_address )
                          }]
                        });
                        var htlc_sig = tapscript.Signer.segwit.sign( privkey, htlc_txdata, 0, {script: htlc_script} );
                        htlc_txdata.vin[ 0 ].witness = [ htlc_sig, "ab".repeat( 32 ), htlc_script ];
                        var htlc_txhex_if_vicky_received_and_paul_broadcasted = tapscript.Tx.encode( htlc_txdata ).hex;
                    }
                }
                var new_tx_commit_pauls_sig_vicky = tapscript.Signer.taproot.sign( privkey, new_tx_commit_txdata, 0, { extension: tapscript.Tap.encodeScript( new_tx_commit_scripts[ 1 ] ) });
                var vickys_amt = new_tx_commit_amt - amount_for_paul - 500;
                var new_tx_commit_pauls_sig = tapscript.Signer.taproot.sign( privkey, new_tx_commit_txdata, 0, { extension: tapscript.Tap.encodeScript( new_tx_commit_scripts[ 1 ] ) });
                var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length + 1;
                var msgnum = 15;
                var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${pauls_new_publication_hash}${pauls_new_revocation_hash}${pauls_address}`;
                var msghash = await sha256( msg_to_sign );
                var sig = await nobleSecp256k1.sign( msghash, privkey );
                // console.log( `new pub & rev hashes & btc address: ${JSON.stringify( [ msgnum, channel_identifier, sig, pauls_new_publication_hash, pauls_new_revocation_hash, pauls_address] )}` );
                //todo: use more relays
                alert( `Hit ok to send msg ${msgnum}` );
                await sendDM( JSON.stringify( [ msgnum, channel_identifier, sig, pauls_new_publication_hash, pauls_new_revocation_hash, pauls_address] ), vickys_key.substring( 2 ), "wss://nostrue.com", pauls_key.substring( 2 ), privkey, msgnum );
                showToast( `sent message ${msgnum}` );
                await waitSomeSeconds( 2 );
                console.log( `sent message ${msgnum}` );
                // alert( `Give Vicky the data in your console` );
                //todo: use more relays
                var msgnum = 20;
                alert( `Hit ok when your counterparty sent message ${msgnum}` );
                var msg_from_counterparty = await getDMs( [ pauls_key.substring( 2 ) ], "wss://nostrue.com" );
                try {
                    var vickys_data = decrypt( privkey, msg_from_counterparty.pubkey, msg_from_counterparty.content );
                } catch( e ) {
                    //todo: automate the force close
                    return alert( `Your counterparty stopped responding during a state update! Time to force close` );
                }
                console.log( `Got message ${msgnum}`, vickys_data );
                // var vickys_data = prompt( `enter Vicky's three new signatures` );
                vickys_data = JSON.parse( vickys_data );
                var channel_identifier = vickys_data[ 1 ];
                var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length + 1;
                var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${vickys_data[ 3 ]}${vickys_data[ 4 ]}${vickys_data[ 5 ]}`;
                var msghash = await sha256( msg_to_sign );
                var sig = vickys_data[ 2 ];
                var sig_is_valid = await nobleSecp256k1.verify( sig, msghash, vickys_key );
                //todo: automate the force close
                if ( !sig_is_valid ) return alert( `Something went wrong with message 20! Time to force close!` );
                //the following sig should move the money from the funding address to the new_post_funding address
                var new_tx_funding_vickys_sig = vickys_data[ 3 ];
                var sighash = tapscript.Signer.segwit.hash( new_tx_funding_txdata, 0, { script: tx_funding_script } );
                var sigflag = new_tx_funding_vickys_sig.substring( new_tx_funding_vickys_sig.length - 2 );
                if ( sigflag != "01" ) return alert( `new_tx_funding sig was not good due to bad sigflag! Aborting, broadcast these transactions:\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "to_reveal" ]}\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "to_delay" ]}\n\nThen wait 1008 blocks, then broadcast this transaction:\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "final_tx" ]}` );
                var sig_is_good = await nobleSecp256k1.verify( new_tx_funding_vickys_sig.substring( 0, new_tx_funding_vickys_sig.length - 2 ), bytesToHex( sighash ), vickys_key );
                if ( !sig_is_good ) return alert( `new_tx_funding sig was not good due to not validating! Aborting, broadcast these transactions:\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "to_reveal" ]}\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "to_delay" ]}\n\nThen wait 1008 blocks, then broadcast this transaction:\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "final_tx" ]}` );
                new_tx_funding_txdata.vin[ 0 ].witness = [ 0, new_tx_funding_pauls_sig, new_tx_funding_vickys_sig, tx_funding_script ];
                var new_tx_funding_txhex = tapscript.Tx.encode( new_tx_funding_txdata ).hex;
                //the following sig should move the money from the new_post_funding address to the new_tx_commit address
                var new_post_funding_vickys_sig = vickys_data[ 4 ];
                var sighash = tapscript.Signer.segwit.hash( new_post_funding_txdata, 0, { script: new_post_funding_script_paul } );
                var sigflag = new_post_funding_vickys_sig.substring( new_post_funding_vickys_sig.length - 2 );
                if ( sigflag != "01" ) return alert( `new_post_funding sig was not good! Aborting, broadcast these transactions:\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "to_reveal" ]}\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "to_delay" ]}\n\nThen wait 1008 blocks, then broadcast this transaction:\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "final_tx" ]}` );
                var sig_is_good = await nobleSecp256k1.verify( new_post_funding_vickys_sig.substring( 0, new_post_funding_vickys_sig.length - 2 ), bytesToHex( sighash ), vickys_key );
                if ( !sig_is_good ) return alert( `new_post_funding sig was not good! Aborting, broadcast these transactions:\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "to_reveal" ]}\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "to_delay" ]}\n\nThen wait 1008 blocks, then broadcast this transaction:\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "final_tx" ]}` );
                new_post_funding_txdata.vin[ 0 ].witness = [ 0, new_post_funding_pauls_sig, new_post_funding_vickys_sig, pauls_new_publication_preimage, new_post_funding_script_paul ];
                var new_post_funding_txhex = tapscript.Tx.encode( new_post_funding_txdata ).hex;
                //the following sig should move the money from the new_tx_commit address to vicky
                var new_tx_commit_vickys_sig = vickys_data[ 5 ];
                var sighash = tapscript.Signer.taproot.hash( new_tx_commit_txdata, 0, { extension: tapscript.Tap.encodeScript( new_tx_commit_scripts[ 1 ] ) } );
                if ( new_tx_commit_vickys_sig.length > 128 ) return alert( `new_tx_commit sig was not good! Aborting, broadcast these transactions:\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "to_reveal" ]}\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "to_delay" ]}\n\nThen wait 1008 blocks, then broadcast this transaction:\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "final_tx" ]}` );
                var sig_is_good = await nobleSecp256k1.schnorr.verify( new_tx_commit_pauls_sig, bytesToHex( sighash ), pauls_key.substring( 2 ) );
                if ( !sig_is_good ) return alert( `new_tx_commit sig was not good! Aborting, broadcast these transactions:\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "to_reveal" ]}\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "to_delay" ]}\n\nThen wait 1008 blocks, then broadcast this transaction:\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "final_tx" ]}` );
                new_tx_commit_txdata.vin[ 0 ].witness = [ new_tx_commit_vickys_sig, new_tx_commit_pauls_sig, new_tx_commit_scripts[ 1 ], new_tx_commit_cblock ];
                var new_tx_commit_txhex = tapscript.Tx.encode( new_tx_commit_txdata ).hex;
                var old_state = paul_channels[ channel_identifier ][ "force_close_txs" ];
                paul_channels[ channel_identifier ][ "old_states" ].push( old_state );
                var new_state = {
                    to_reveal: new_tx_funding_txhex,
                    to_delay: new_post_funding_txhex,
                    final_tx: new_tx_commit_txhex,
                    vickys_publication_hash: vickys_new_publication_hash,
                    vickys_revocation_hash: vickys_new_revocation_hash,
                    pauls_publication_preimage: pauls_new_publication_preimage,
                    pauls_revocation_preimage: pauls_new_revocation_preimage,
                }
                if ( pmthash && htlc_txhex_if_paul_received_and_paul_broadcasted ) new_state[ "htlc_txhex_if_paul_received_and_paul_broadcasted" ] = htlc_txhex_if_paul_received_and_paul_broadcasted;
                if ( pmthash && htlc_txhex_if_vicky_received_and_paul_broadcasted ) paul_channels[ channel_identifier ][ "force_close_txs" ][ "htlc_txhex_if_vicky_received_and_paul_broadcasted" ] = htlc_txhex_if_vicky_received_and_paul_broadcasted;
                if ( pmthash ) new_state[ "pmthash" ] = pmthash;
                if ( preimage ) new_state[ "preimage" ] = preimage;
                paul_channels[ channel_identifier ][ "force_close_txs" ] = new_state;
                if ( !( "balance" in paul_channels[ channel_identifier ] ) ) paul_channels[ channel_identifier ][ "balance" ] = {}
                var reserve_amount_before_update = paul_channels[ channel_identifier ][ "balance" ][ "reserve" ];
                paul_channels[ channel_identifier ][ "balance" ][ "reserve" ] = amount_for_paul > 2000 ? 2000 : amount_for_paul;
                var reserve_amount_after_update = paul_channels[ channel_identifier ][ "balance" ][ "reserve" ];
                var amount_added_to_reserve = reserve_amount_after_update - reserve_amount_before_update;
                paul_channels[ channel_identifier ][ "balance" ][ "local" ] = amount_for_paul > 2000 ? amount_for_paul - 2000 : amount_for_paul;
                paul_channels[ channel_identifier ][ "balance" ][ "remote" ] = paul_channels[ channel_identifier ][ "tx_funding_amt" ] + 500 - ( paul_channels[ channel_identifier ][ "balance" ][ "reserve" ] + paul_channels[ channel_identifier ][ "balance" ][ "local" ] );
                //versions for vicky
                var new_tx_funding_txdata = tapscript.Tx.create({
                  vin  : [{
                    txid: tx_funding_txid,
                    vout: tx_funding_vout,
                    prevout: {
                      value: tx_funding_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( tx_funding_address )
                    },
                  }],
                  vout : [{
                    value: tx_funding_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( new_post_funding_address_vicky )
                  }]
                });
                var new_tx_funding_pauls_sig_vicky = tapscript.Signer.segwit.sign( privkey, new_tx_funding_txdata, 0, { script: tx_funding_script });
                var new_tx_funding_txhex = tapscript.Tx.encode( new_tx_funding_txdata ).hex;
                var new_post_funding_txid = tapscript.Tx.util.getTxid( new_tx_funding_txhex );
                paul_channels[ channel_identifier ][ "force_close_txs" ][ "other_partys_to_reveal_txid" ] = new_post_funding_txid;
                var new_post_funding_vout = 0;
                var new_post_funding_amt = tx_funding_amt - 500;
                var new_post_funding_txdata = tapscript.Tx.create({
                  vin  : [{
                    txid: new_post_funding_txid,
                    vout: new_post_funding_vout,
                    prevout: {
                      value: new_post_funding_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( new_post_funding_address_vicky )
                    },
                  }],
                  vout : [{
                    value: new_post_funding_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( new_tx_commit_address )
                  }]
                });
                var sighash = tapscript.Signer.segwit.hash( new_post_funding_txdata, 0, { script: new_post_funding_script_vicky } );
                var new_post_funding_pauls_sig_vicky = tapscript.Signer.segwit.sign( privkey, new_post_funding_txdata, 0, { script: new_post_funding_script_vicky });
                var new_post_funding_txhex = tapscript.Tx.encode( new_post_funding_txdata ).hex;
                var new_tx_commit_txid = tapscript.Tx.util.getTxid( new_post_funding_txhex );
                paul_channels[ channel_identifier ][ "force_close_txs" ][ "other_partys_to_delay_txid" ] = new_tx_commit_txid;
                var new_tx_commit_vout = 0;
                var new_tx_commit_amt = new_post_funding_amt - 500;
                var vickys_address = paul_channels[ channel_identifier ][ "vickys_address" ];
                var new_tx_commit_txdata = tapscript.Tx.create({
                  vin  : [{
                    txid: new_tx_commit_txid,
                    vout: new_tx_commit_vout,
                    //todo: fix this sequence
                    // sequence: 144 * 7,
                    sequence: 1 * 7,
                    prevout: {
                      value: new_tx_commit_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( new_tx_commit_address )
                    },
                  }],
                  vout : []
                });
                var timelock = 8;
                if ( pmthash && amount_paul_will_get > 0 ) {
                    var htlc_script = generateHtlcWherePaulReceives( pauls_key, vickys_key, pmthash, timelock );
                    var htlc_address = tapscript.Address.p2wsh.fromScript( htlc_script, "regtest" );
                    new_tx_commit_txdata[ "vout" ].push({
                        value: new_tx_commit_amt - amount_for_paul - 500,
                        scriptPubKey: tapscript.Address.toScriptPubKey( vickys_address )
                    },{
                        value: amount_for_paul,
                        scriptPubKey: tapscript.Address.toScriptPubKey( htlc_address )
                    });
                }
                if ( pmthash && amount_paul_will_get < 0 ) {
                    var htlc_script = generateHtlcWhereVickyReceives( pauls_key, vickys_key, pmthash, timelock );
                    var htlc_address = tapscript.Address.p2wsh.fromScript( htlc_script, "regtest" );
                    new_tx_commit_txdata[ "vout" ].push({
                        value: new_tx_commit_amt - amount_for_paul - 500,
                        scriptPubKey: tapscript.Address.toScriptPubKey( htlc_address )
                    },{
                        value: amount_for_paul,
                        scriptPubKey: tapscript.Address.toScriptPubKey( pauls_address )
                    });
                }
                if ( !pmthash ) {
                    new_tx_commit_txdata[ "vout" ].push({
                        value: new_tx_commit_amt - amount_for_paul - 500,
                        scriptPubKey: tapscript.Address.toScriptPubKey( vickys_address )
                    },{
                        value: amount_for_paul,
                        scriptPubKey: tapscript.Address.toScriptPubKey( pauls_address )
                    });
                }
                if ( pmthash ) {
                    var new_tx_commit_txhex = tapscript.Tx.encode( new_tx_commit_txdata ).hex;
                    var new_htlc_txid = tapscript.Tx.util.getTxid( new_tx_commit_txhex );
                    if ( preimage ) {
                        var htlc_script = generateHtlcWherePaulReceives( pauls_key, vickys_key, pmthash, timelock );
                        var htlc_address = tapscript.Address.p2wsh.fromScript( htlc_script, "regtest" );
                        var htlc_txdata = tapscript.Tx.create({
                          vin  : [{
                            txid: new_htlc_txid,
                            vout: 1,
                            prevout: {
                              value: amount_for_paul,
                              scriptPubKey: tapscript.Address.toScriptPubKey( htlc_address )
                            },
                          }],
                          vout : [{
                            value: amount_for_paul - 500,
                            scriptPubKey: tapscript.Address.toScriptPubKey( pauls_address )
                          }]
                        });
                        var htlc_sig = tapscript.Signer.segwit.sign( privkey, htlc_txdata, 0, {script: htlc_script} );
                        htlc_txdata.vin[ 0 ].witness = [ htlc_sig, preimage, htlc_script ];
                        var htlc_txhex_if_paul_received_and_vicky_broadcasted = tapscript.Tx.encode( htlc_txdata ).hex;
                    } else {
                        var htlc_script = generateHtlcWhereVickyReceives( pauls_key, vickys_key, pmthash, timelock );
                        var htlc_address = tapscript.Address.p2wsh.fromScript( htlc_script, "regtest" );
                        var htlc_txdata = tapscript.Tx.create({
                          vin  : [{
                            txid: new_htlc_txid,
                            vout: 0,
                            seqence: timelock,
                            prevout: {
                              value: new_tx_commit_amt - amount_for_paul - 500,
                              scriptPubKey: tapscript.Address.toScriptPubKey( htlc_address )
                            },
                          }],
                          vout : [{
                            value: new_tx_commit_amt - amount_for_paul - 500 - 500,
                            scriptPubKey: tapscript.Address.toScriptPubKey( pauls_address )
                          }]
                        });
                        var htlc_sig = tapscript.Signer.segwit.sign( privkey, htlc_txdata, 0, {script: htlc_script} );
                        htlc_txdata.vin[ 0 ].witness = [ htlc_sig, "ab".repeat( 32 ), htlc_script ];
                        var htlc_txhex_if_vicky_received_and_vicky_broadcasted = tapscript.Tx.encode( htlc_txdata ).hex;
                    }
                }
                if ( pmthash && htlc_txhex_if_paul_received_and_vicky_broadcasted ) new_state[ "htlc_txhex_if_paul_received_and_vicky_broadcasted" ] = htlc_txhex_if_paul_received_and_vicky_broadcasted;
                if ( pmthash && htlc_txhex_if_vicky_received_and_vicky_broadcasted ) paul_channels[ channel_identifier ][ "force_close_txs" ][ "htlc_txhex_if_vicky_received_and_vicky_broadcasted" ] = htlc_txhex_if_vicky_received_and_vicky_broadcasted;
                var new_tx_commit_pauls_sig_vicky = tapscript.Signer.taproot.sign( privkey, new_tx_commit_txdata, 0, { extension: tapscript.Tap.encodeScript( new_tx_commit_scripts[ 1 ] ) });
                var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length;
                var msgnum = 25;
                var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${new_tx_funding_pauls_sig_vicky.hex}${new_post_funding_pauls_sig_vicky.hex}${new_tx_commit_pauls_sig_vicky.hex}`;
                var msghash = await sha256( msg_to_sign );
                var sig = await nobleSecp256k1.sign( msghash, privkey );
                // console.log( `give this data to Vicky: ${ JSON.stringify( [ msgnum, channel_identifier, sig, new_tx_funding_pauls_sig_vicky.hex, new_post_funding_pauls_sig_vicky.hex, new_tx_commit_pauls_sig_vicky.hex] ) }`);
                //todo: use more relays
                alert( `Hit ok to send msg ${msgnum}` );
                await sendDM( JSON.stringify( [ msgnum, channel_identifier, sig, new_tx_funding_pauls_sig_vicky.hex, new_post_funding_pauls_sig_vicky.hex, new_tx_commit_pauls_sig_vicky.hex] ), vickys_key.substring( 2 ), "wss://nostrue.com", pauls_key.substring( 2 ), privkey, msgnum );
                showToast( `sent message ${msgnum}` );
                await waitSomeSeconds( 2 );
                console.log( `sent message ${msgnum}` );
                // alert( `Send the info in your console to Vicky` );
                //todo: use more relays
                var msgnum = 30;
                alert( `Hit ok when your counterparty sent message ${msgnum}` );
                var msg_from_counterparty = await getDMs( [ pauls_key.substring( 2 ) ], "wss://nostrue.com" );
                try {
                    var vickys_data = decrypt( privkey, msg_from_counterparty.pubkey, msg_from_counterparty.content );
                } catch( e ) {
                    //todo: automate the force close
                    return alert( `Your counterparty stopped responding during a state update! Time to force close` );
                }
                console.log( `Got message ${msgnum}`, vickys_data );
                // var vickys_data = prompt( `enter Vicky's revocation preimage for state ${paul_channels[ channel_identifier ][ "old_states" ].length - 1}` );
                vickys_data = JSON.parse( vickys_data );
                var channel_identifier = vickys_data[ 1 ];
                var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length;
                var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${vickys_data[ 3 ]}`;
                console.log( "msg_to_sign:", msg_to_sign );
                var msghash = await sha256( msg_to_sign );
                var sig = vickys_data[ 2 ];
                var sig_is_valid = await nobleSecp256k1.verify( sig, msghash, vickys_key );
                //todo: automate the force close
                if ( !sig_is_valid ) return alert( `Something went wrong with message 30! Time to force close!` );
                var vickys_revocation_preimage = vickys_data[ 3 ];
                var vickys_revocation_hash = paul_channels[ channel_identifier ][ "old_states" ][ paul_channels[ channel_identifier ][ "old_states" ].length - 1 ][ "vickys_revocation_hash" ];
                if ( rmd160( hexToBytes( vickys_revocation_preimage ) ) != vickys_revocation_hash ) return alert( `Time to force close! Vicky sent you a wrong revocation preimage! Broadcast these transactions:\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "to_reveal" ]}\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "to_delay" ]}\n\nThen wait 1008 blocks, then broadcast this transaction:\n\n${paul_channels[ channel_identifier ][ "force_close_txs" ][ "final_tx" ]}` );
                paul_channels[ channel_identifier ][ "old_states" ][ paul_channels[ channel_identifier ][ "old_states" ].length - 1 ][ "vickys_revocation_preimage" ] = vickys_revocation_preimage;
                var transitioning_to = paul_channels[ channel_identifier ][ "old_states" ].length;
                var msgnum = 35;
                var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${paul_channels[ channel_identifier ][ "old_states" ][ paul_channels[ channel_identifier ][ "old_states" ].length - 1 ][ "pauls_revocation_preimage" ]}`;
                var msghash = await sha256( msg_to_sign );
                var sig = await nobleSecp256k1.sign( msghash, privkey );
                // console.log( `Send this revocation preimage to Vicky: ${JSON.stringify( [ msgnum, channel_identifier, sig, paul_channels[ channel_identifier ][ "old_states" ][ paul_channels[ channel_identifier ][ "old_states" ].length - 1 ][ "pauls_revocation_preimage" ] ] )}` );
                //todo: use more relays
                alert( `Hit ok to send msg ${msgnum}` );
                await sendDM( JSON.stringify( [ msgnum, channel_identifier, sig, paul_channels[ channel_identifier ][ "old_states" ][ paul_channels[ channel_identifier ][ "old_states" ].length - 1 ][ "pauls_revocation_preimage" ] ] ), vickys_key.substring( 2 ), "wss://nostrue.com", pauls_key.substring( 2 ), privkey, msgnum );
                showToast( `sent message ${msgnum}` );
                await waitSomeSeconds( 2 );
                console.log( `sent message ${msgnum}` );
                // alert( `send Vicky your revocation preimage (it is in your console)` );
            }
            var getDMs = async ( pubkeys, relay ) => {
                return new Promise( async function( resolve, reject ) {
                    var started_waiting_time = Math.floor( Date.now() / 1000 );
                    var relays = [ relay ];
                    var resolveEvent = async event => {
                        if ( !event ) return;
                        var event = JSON.parse( event.data );
                        if ( !event[ 2 ] || event[ 2 ] === true ) return;
                        var sig = event[ 2 ].sig;
                        var eventData = JSON.stringify([
                            0,
                            event[ 2 ]['pubkey'],
                            event[ 2 ]['created_at'],
                            event[ 2 ]['kind'],
                            event[ 2 ]['tags'],
                            event[ 2 ]['content']
                        ]);
                        var id  = await sha256( eventData ).toString( 'hex' );
                        var valid = await nobleSecp256k1.schnorr.verify( sig, id, event[ 2 ].pubkey );
                        resolve( event[ 2 ] );
                    }
                    socket.close();
                    await waitSomeSeconds( 1 );
                    socket = {}
                    socket = new WebSocket( relay );
                    socket.addEventListener( 'message', resolveEvent );
                    var randomid = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 16 );
                    var filter = { "#p": pubkeys, "since": started_waiting_time - 30, "limit": 1 }
                    var subscription = [ "REQ", randomid, filter ];
                    subscription = JSON.stringify( subscription );
                    socket.addEventListener( 'open', () => {socket.send( subscription );});
                    setTimeout( () => {resolve( "not found" )}, 10000 );
                });
            }
            async function getSignedEvent( event, privateKey ) {
                var eventData = JSON.stringify([
                    0,
                    event['pubkey'],
                    event['created_at'],
                    event['kind'],
                    event['tags'],
                    event['content']
                ]);
                var id = await sha256( eventData );
                event.id = id;
                event.sig = await nobleSecp256k1.schnorr.sign( event.id, privateKey );
                return event;
            }
            var sendDM = async ( note, recipient, relay, mypubkey, myprivkey, num ) => {
                var event = {
                    "content": encrypt( myprivkey, recipient, note ),
                    "created_at": Math.floor( Date.now() / 1000 ),
                    "kind": 4,
                    "tags": [ [ "p", recipient ], [ "num", String( num ) ] ],
                    "pubkey": mypubkey
                }
                var signed_event = await getSignedEvent( event, myprivkey );
                await eventWasReplayedTilSeen( signed_event.id, relay, 0, signed_event );
                return signed_event;
            }
            function encrypt( privkey, pubkey, text ) {
                var key = nobleSecp256k1.getSharedSecret( privkey, '02' + pubkey, true ).substring( 2 );
                var iv = hexToBytes( getRand( 16 ) );
                var cipher = browserifyCipher.createCipheriv( 'aes-256-cbc', hexToBytes( key ), iv );
                var encryptedMessage = cipher.update(text,"utf8","base64");
                emsg = encryptedMessage + cipher.final( "base64" );
                var uint8View = new Uint8Array( iv.buffer );
                var decoder = new TextDecoder();
                return emsg + "?iv=" + btoa( String.fromCharCode.apply( null, uint8View ) );
            }
            function decrypt( privkey, pubkey, ciphertext ) {
                var [ emsg, iv ] = ciphertext.split( "?iv=" );
                var key = nobleSecp256k1.getSharedSecret( privkey, '02' + pubkey, true ).substring( 2 );
                var decipher = browserifyCipher.createDecipheriv(
                    'aes-256-cbc',
                    hexToBytes( key ),
                    hexToBytes( base64ToHex( iv ) )
                );
                var decryptedMessage = decipher.update( emsg, "base64" );
                dmsg = decryptedMessage + decipher.final( "utf8" );
                return dmsg;
            }
            var waitSomeSeconds = num => {
                var num = num.toString() + "000";
                num = Number( num );
                return new Promise( resolve => setTimeout( resolve, num ) );
            }
            function showToast( content ) {
                var x = $( '.toast' );
                x.innerHTML = content;
                x.classList.add( "show" );
                setTimeout(function(){ x.classList.remove( "show" ); }, 3000);
            }
            var eventWasReplayedTilSeen = async ( event_id, the_relay, num, event, rate_limit_num = 10 ) => {
                if ( !num ) num = 0;
                if ( num == 0 ) {
                    if ( socket.readyState == 1 ) {
                        socket.send( JSON.stringify( ["EVENT", event ] ) );
                    } else {
                        socket.close();
                        await waitSomeSeconds( 1 );
                        socket = {}
                        socket = new WebSocket( relay );                        
                        socket.addEventListener( 'open', () => {
                            socket.send( JSON.stringify( ["EVENT", event ] ) );
                        });
                    }
                }
                var response = await getNostrNote( event_id, the_relay );
                console.log( 'response:', response );
                if ( response != "time is up" && response != "not found" ) return true;
                console.log( "replaying this event:", event_id, "at this relay:", the_relay );
                num = num + 1;
                if ( socket.readyState == 1 ) {
                    socket.send( JSON.stringify( ["EVENT", event ] ) );
                } else {
                    socket.close();
                    await waitSomeSeconds( 1 );
                    socket = {}
                    socket = new WebSocket( relay );                        
                    socket.addEventListener( 'open', () => {
                        socket.send( JSON.stringify( ["EVENT", event ] ) );
                    });
                }
                var was_seen = false;
                if ( num < 2 ) was_seen = await eventWasReplayedTilSeen( event_id, the_relay, num, event, rate_limit_num );
                if ( !was_seen ) {
                    showToast( `Rate limit exceeded, waiting ${rate_limit_num} seconds and retrying` );
                    countdown( rate_limit_num );
                    await waitSomeSeconds( rate_limit_num );
                    rate_limit_num = rate_limit_num * 2;
                    was_seen = await eventWasReplayedTilSeen( event_id, the_relay, num, event, rate_limit_num );
                }
                return was_seen;
            }
            var countdown = async ( num = 40 ) => {
                console.log( num );
                if ( !( num % 4 ) ) showToast( num );
                await waitSomeSeconds( 1 );
                if ( num > 0 ) countdown( num - 1 );
            }
            var getNostrNote = async ( id, relay ) => {
                return new Promise( async function( resolve, reject ) {
                    var started_waiting_time = Math.floor( Date.now() / 1000 );
                    var relays = [ relay ];
                    var resolveEvent = async event => {
                        if ( !event ) return;
                        var event = JSON.parse( event.data );
                        if ( !event[ 2 ] || event[ 2 ] === true ) return;
                        var sig = event[ 2 ].sig;
                        var eventData = JSON.stringify([
                            0,
                            event[ 2 ]['pubkey'],
                            event[ 2 ]['created_at'],
                            event[ 2 ]['kind'],
                            event[ 2 ]['tags'],
                            event[ 2 ]['content']
                        ]);
                        var id  = await sha256( eventData );
                        var valid = await nobleSecp256k1.schnorr.verify( sig, id, event[ 2 ].pubkey );
                        resolve( event[ 2 ] );
                    }
                    socket.close();
                    await waitSomeSeconds( 1 );
                    socket = {}
                    socket = new WebSocket( relay );
                    socket.addEventListener( 'message', resolveEvent );
                    var randomid = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 16 );
                    var filter = { "ids": [ id ] }
                    var subscription = [ "REQ", randomid, filter ];
                    subscription = JSON.stringify( subscription );
                    socket.addEventListener( 'open', () => {socket.send( subscription );});
                    setTimeout( () => {resolve( "not found" )}, 10000 );
                });
            }
        </script>
    </head>
    <body>
        <h1>Hi Paul</h1>
        <script>
            var paul_channels = {}
            var relay = "wss://nostrue.com";
            var socket = new WebSocket( relay );
            var createChannel = async () => {
                var refund_cblock = null;
                var privkey = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                var pauls_key = nobleSecp256k1.getPublicKey( privkey, true );
                var publication_privkey = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                var pauls_publication_preimage = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                var pauls_publication_hash = rmd160( hexToBytes( pauls_publication_preimage ) );
                var pauls_revocation_preimage = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                var pauls_revocation_hash = rmd160( hexToBytes( pauls_revocation_preimage ) );
                var revocation_privkey = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                //to create the message to sign, concatenate the following items, then hash the result: channel identifier, state you are transitioning to (e.g. 0, 1, 2, etc.), message number, all items after the signature itself
                var channel_identifier = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                var transitioning_to = 0;
                var msgnum = 0;
                var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${pauls_key}${pauls_publication_hash}${pauls_revocation_hash}`;
                var msghash = await sha256( msg_to_sign );
                var sig = await nobleSecp256k1.sign( msghash, privkey );
                console.log( "send this to Vicky:", JSON.stringify( [ msgnum, channel_identifier, sig, pauls_key, pauls_publication_hash, pauls_revocation_hash ] ) );
                // alert( `send Vicky your key, publication hash, and revocation hash (they are in your console -- if you don't see them there, refresh your page repeatedly til you do)` );
                //todo: use more relays
                var msgnum = 1;
                alert( `Hit ok when your counterparty's browser says it is done sending message ${msgnum}` );
                var msg_from_counterparty = await getDMs( [ pauls_key.substring( 2 ) ], "wss://nostrue.com" );
                try {
                    var data_from_vicky = decrypt( privkey, msg_from_counterparty.pubkey, msg_from_counterparty.content );
                } catch( e ) {
                    //todo: automate the force close
                    return alert( `Your counterparty stopped responding during a state update! Time to force close` );
                }
                console.log( `Got message ${msgnum}`, data_from_vicky );
                // var data_from_vicky = prompt( `enter the info from Vicky` );
                data_from_vicky = JSON.parse( data_from_vicky );
                var prefunding_txid = data_from_vicky[ 3 ][ "prefunding_txid" ];
                var prefunding_vout = data_from_vicky[ 3 ][ "prefunding_vout" ];
                var prefunding_amt = data_from_vicky[ 3 ][ "prefunding_amt" ];
                var vickys_key = data_from_vicky[ 3 ][ "vickys_key" ];
                var vickys_publication_hash = data_from_vicky[ 3 ][ "vickys_publication_hash" ];
                var vickys_revocation_hash = data_from_vicky[ 3 ][ "vickys_revocation_hash" ];
                var vickys_address = data_from_vicky[ 3 ][ "vickys_address" ];
                var prefunding_address = data_from_vicky[ 3 ][ "prefunding_address" ];
                var channel_identifier = data_from_vicky[ 1 ];
                var transitioning_to = 0;
                var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${JSON.stringify(data_from_vicky[ 3 ])}`;
                var msghash = await sha256( msg_to_sign );
                var sig = data_from_vicky[ 2 ];
                var sig_is_valid = await nobleSecp256k1.verify( sig, msghash, vickys_key );
                if ( !sig_is_valid ) return;
                //todo: fix the sequence which should be 144 * 7 not 1 * 7
                var refund_scripts = [
                    [ 'OP_RIPEMD160', vickys_publication_hash, 'OP_EQUALVERIFY', 'OP_RIPEMD160', vickys_revocation_hash, 'OP_EQUALVERIFY', pauls_key.substring( 2 ), 'OP_CHECKSIG' ],
                    [ 0, pauls_key.substring( 2 ), 'OP_CHECKSIGADD', vickys_key.substring( 2 ), 'OP_CHECKSIGADD', 2, 'OP_EQUALVERIFY', 1 * 7, 'OP_CHECKSEQUENCEVERIFY', 'OP_0NOTEQUAL' ],
                    [ 'OP_RIPEMD160', pauls_publication_hash, 'OP_EQUALVERIFY', 'OP_RIPEMD160', pauls_revocation_hash, 'OP_EQUALVERIFY', vickys_key.substring( 2 ), 'OP_CHECKSIG' ]
                ];
                var refund_tree = refund_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                var [ refund_tpubkey, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: refund_tree });
                refund_cblock = cblock;
                var refund_address = tapscript.Address.p2tr.fromPubKey( refund_tpubkey, 'regtest' );
                var tx_funding_script = [
                    2,
                    pauls_key,
                    vickys_key,
                    2,
                    'OP_CHECKMULTISIG'
                ];
                var tx_funding_address = tapscript.Address.p2wsh.fromScript( tx_funding_script, "regtest" );
                var post_funding_script_paul = [
                    'OP_RIPEMD160',
                    pauls_publication_hash,
                    'OP_EQUAL',
                    'OP_NOTIF',
                        'OP_10',
                        'OP_CHECKSEQUENCEVERIFY',
                        'OP_DROP',
                    'OP_ENDIF',
                    2,
                    pauls_key,
                    vickys_key,
                    2,
                    'OP_CHECKMULTISIG'
                ];
                // var tx_funding_script = [ 2, pauls_key, vickys_key, 2, 'OP_CHECKMULTISIG' ];
                var post_funding_address_paul = tapscript.Address.p2wsh.fromScript( post_funding_script_paul, "regtest" );
                var post_funding_script_vicky = [
                    'OP_RIPEMD160',
                    vickys_publication_hash,
                    'OP_EQUAL',
                    'OP_IF',
                        2,
                        pauls_key,
                        vickys_key,
                        2,
                        'OP_CHECKMULTISIG',
                    'OP_ELSE',
                        'OP_10',
                        'OP_CHECKSEQUENCEVERIFY',
                        'OP_DROP',
                        pauls_key,
                        'OP_CHECKSIG',
                    'OP_ENDIF',
                ];
                // var tx_funding_script = [ 2, pauls_key, vickys_key, 2, 'OP_CHECKMULTISIG' ];
                var post_funding_address_vicky = tapscript.Address.p2wsh.fromScript( post_funding_script_vicky, "regtest" );
                var prefunding_txdata = tapscript.Tx.create({
                  vin  : [{
                    txid: prefunding_txid,
                    vout: prefunding_vout,
                    prevout: {
                      value: prefunding_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( prefunding_address )
                    },
                  }],
                  vout : [{
                    value: prefunding_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( tx_funding_address )
                  }]
                });
                var prefunding_txhex = tapscript.Tx.encode( prefunding_txdata ).hex;
                var tx_funding_txid = tapscript.Tx.util.getTxid( prefunding_txhex );
                var tx_funding_vout = 0;
                var tx_funding_amt = prefunding_amt - 500;
                var tx_funding_txdata_paul = tapscript.Tx.create({
                  vin  : [{
                    txid: tx_funding_txid,
                    vout: tx_funding_vout,
                    prevout: {
                      value: tx_funding_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( tx_funding_address )
                    },
                  }],
                  vout : [{
                    value: tx_funding_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( post_funding_address_paul )
                  }]
                });
                var sighash = tapscript.Signer.segwit.hash( tx_funding_txdata_paul, 0, { script: tx_funding_script } );
                var tx_funding_pauls_sig = tapscript.Signer.segwit.sign( privkey, tx_funding_txdata_paul, 0, { script: tx_funding_script });
                tx_funding_txdata_paul.vin[ 0 ].witness = [ 0, 0, tx_funding_pauls_sig, tx_funding_script ];
                var tx_funding_txhex_paul = tapscript.Tx.encode( tx_funding_txdata_paul ).hex;
                var post_funding_txid = tapscript.Tx.util.getTxid( tx_funding_txhex_paul );
                var post_funding_vout = 0;
                var post_funding_amt = tx_funding_amt - 500;
                var post_funding_txdata_paul = tapscript.Tx.create({
                  vin  : [{
                    txid: post_funding_txid,
                    vout: post_funding_vout,
                    prevout: {
                      value: post_funding_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( post_funding_address_paul )
                    },
                  }],
                  vout : [{
                    value: post_funding_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( refund_address )
                  }]
                });
                var post_funding_pauls_sig = tapscript.Signer.segwit.sign( privkey, post_funding_txdata_paul, 0, { script: post_funding_script_paul });
                var post_funding_txhex_paul = tapscript.Tx.encode( post_funding_txdata_paul ).hex;
                var tx_refund_txid = tapscript.Tx.util.getTxid( post_funding_txhex_paul );
                var tx_refund_vout = 0;
                var tx_refund_amt = post_funding_amt - 500;
                var tx_refund_txdata_paul = tapscript.Tx.create({
                  vin  : [{
                    txid: tx_refund_txid,
                    vout: tx_refund_vout,
                    //todo: fix the sequence
                    // sequence: 144 * 7,
                    sequence: 1 * 7,
                    prevout: {
                      value: tx_refund_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( refund_address )
                    },
                  }],
                  vout : [{
                    value: tx_refund_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( vickys_address )
                  }]
                });
                var tx_refund_pauls_sig = tapscript.Signer.taproot.sign( privkey, tx_refund_txdata_paul, 0, { extension: tapscript.Tap.encodeScript( refund_scripts[ 1 ] ) });
                //the following sig should move the money from the refund address to vicky
                tx_refund_txdata_paul.vin[ 0 ].witness = [ 0, tx_refund_pauls_sig, refund_scripts[ 1 ], refund_cblock ];
                var tx_refund_txhex = tapscript.Tx.encode( tx_refund_txdata_paul ).hex;
                //versions for vicky
                var tx_funding_txdata_vicky = tapscript.Tx.create({
                  vin  : [{
                    txid: tx_funding_txid,
                    vout: tx_funding_vout,
                    prevout: {
                      value: tx_funding_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( tx_funding_address )
                    },
                  }],
                  vout : [{
                    value: tx_funding_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( post_funding_address_vicky )
                  }]
                });
                var tx_funding_pauls_sig_vicky = tapscript.Signer.segwit.sign( privkey, tx_funding_txdata_vicky, 0, { script: tx_funding_script });
                tx_funding_txdata_vicky.vin[ 0 ].witness = [ 0, 0, tx_funding_pauls_sig_vicky, tx_funding_script ];
                var tx_funding_txhex_vicky = tapscript.Tx.encode( tx_funding_txdata_vicky ).hex;
                var post_funding_txid = tapscript.Tx.util.getTxid( tx_funding_txhex_vicky );
                var other_partys_to_reveal_txid = post_funding_txid;
                var post_funding_vout = 0;
                var post_funding_amt = tx_funding_amt - 500;
                var post_funding_txdata_vicky = tapscript.Tx.create({
                  vin  : [{
                    txid: post_funding_txid,
                    vout: post_funding_vout,
                    prevout: {
                      value: post_funding_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( post_funding_address_vicky )
                    },
                  }],
                  vout : [{
                    value: post_funding_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( refund_address )
                  }]
                });
                var post_funding_pauls_sig_vicky = tapscript.Signer.segwit.sign( privkey, post_funding_txdata_vicky, 0, { script: post_funding_script_vicky });
                var post_funding_txhex_vicky = tapscript.Tx.encode( post_funding_txdata_vicky ).hex;
                var tx_refund_txid = tapscript.Tx.util.getTxid( post_funding_txhex_vicky );
                var other_partys_to_delay_txid = tx_refund_txid;
                var tx_refund_vout = 0;
                var tx_refund_amt = post_funding_amt - 500;
                var tx_refund_txdata_vicky = tapscript.Tx.create({
                  vin  : [{
                    txid: tx_refund_txid,
                    vout: tx_refund_vout,
                    //todo: fix the sequence
                    // sequence: 144 * 7,
                    sequence: 1 * 7,
                    prevout: {
                      value: tx_refund_amt,
                      scriptPubKey: tapscript.Address.toScriptPubKey( refund_address )
                    },
                  }],
                  vout : [{
                    value: tx_refund_amt - 500,
                    scriptPubKey: tapscript.Address.toScriptPubKey( vickys_address )
                  }]
                });
                //the following sig should move the money from the refund address to vicky
                var tx_refund_pauls_sig_vicky = tapscript.Signer.taproot.sign( privkey, tx_refund_txdata_vicky, 0, { extension: tapscript.Tap.encodeScript( refund_scripts[ 1 ] ) });
                var transitioning_to = 0;
                var msgnum = 2;
                var msg_to_sign = `${channel_identifier}${transitioning_to}${msgnum}${tx_funding_pauls_sig_vicky.hex}${post_funding_pauls_sig_vicky.hex}${tx_refund_pauls_sig_vicky.hex}`;
                var msghash = await sha256( msg_to_sign );
                var sig = await nobleSecp256k1.sign( msghash, privkey );
                // var pauls_sigs = [ msgnum, channel_identifier, sig, tx_funding_pauls_sig_vicky.hex, post_funding_pauls_sig_vicky.hex, tx_refund_pauls_sig_vicky.hex ];
                // console.log( `give these sigs to Vicky: ${JSON.stringify( pauls_sigs )}` );
                //todo: use more relays
                alert( `Hit ok to send msg ${msgnum}` );
                await sendDM( JSON.stringify( [ msgnum, channel_identifier, sig, tx_funding_pauls_sig_vicky.hex, post_funding_pauls_sig_vicky.hex, tx_refund_pauls_sig_vicky.hex ] ), vickys_key.substring( 2 ), "wss://nostrue.com", pauls_key.substring( 2 ), privkey, msgnum );
                showToast( `sent message ${msgnum}` );
                await waitSomeSeconds( 2 );
                console.log( `sent message ${msgnum}` );
                if ( !( channel_identifier in paul_channels ) ) paul_channels[ channel_identifier ] = {}
                paul_channels[ channel_identifier ][ "force_close_txs" ] = {
                    other_partys_to_reveal_txid,
                    other_partys_to_delay_txid,
                    to_reveal: tx_funding_txhex_paul,
                    to_delay: post_funding_txhex_paul,
                    final_tx: tx_refund_txhex,
                    vickys_publication_hash,
                    vickys_revocation_hash,
                    pauls_publication_preimage,
                    pauls_revocation_preimage,
                }
                paul_channels[ channel_identifier ][ "tx_funding_amt" ] = tx_funding_amt;
                paul_channels[ channel_identifier ][ "tx_funding_address" ] = tx_funding_address;
                paul_channels[ channel_identifier ][ "tx_funding_script" ] = tx_funding_script;
                paul_channels[ channel_identifier ][ "vickys_key" ] = vickys_key;
                paul_channels[ channel_identifier ][ "vickys_address" ] = vickys_address;
                paul_channels[ channel_identifier ][ "balance" ] = {
                    reserve: 0,
                    local: 0,
                    remote: tx_refund_amt - 500,
                }
                paul_channels[ channel_identifier ][ "privkey" ] = privkey;
                paul_channels[ channel_identifier ][ "pauls_key" ] = pauls_key;
                // alert( `Send the data in your console to Vicky` );
            }
            setTimeout( createChannel, 100 );
        </script>
        <div class="toast"></div>
    </body>
</html>
